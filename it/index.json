






[{"content":"","date":"6 novembre 2025","externalUrl":null,"permalink":"/tags/arp/","section":"Tags","summary":"","title":"ARP","type":"tags"},{"content":" ARP 协议介绍 # 说明：\n本文是一个用于介绍 ARP（Address Resolution Protocol，地址解析协议） 的 Verilog 模块示例框架文档。\n你可以在此基础上增删内容、替换图片和表格数据，作为工程文档或学习笔记使用。\n1. 概述（Overview） # ARP（Address Resolution Protocol） 工作在局域网中，用于将 IPv4 地址解析为链路层（以太网） MAC 地址。\n当主机只知道目标 IP 地址时，通过 ARP 在同一广播域内查询对应的 MAC 地址。\n标准来源：RFC 826 所在层次：一般认为位于二层/三层之间 主要功能： 将 IPv4 地址解析为 MAC 地址 维护 ARP 缓存，减少网络广播 为 IP 协议提供底层地址解析能力 2. ARP 工作原理与基本连接 # 2.1 典型网络拓扑结构 # +----------+ +-----------+ +-----------+ | 主机 A | | 交换机 | | 主机 B | | IP: A |\u0026lt;-----\u0026gt; | / 路由器 |\u0026lt;-----\u0026gt;| IP: B | +----------+ +-----------+ +-----------+ | | | |\u0026lt;------ 同一广播域/二层网络 ----------\u0026gt;| 说明：\n当主机 A 需要给主机 B 发送数据：\n检查本地 ARP 缓存表是否已有 B 的 MAC 如果没有，则广播 ARP 请求 B 单播 ARP 应答给 A A 将解析结果缓存并开始正常发送以太网数据帧 2.2 ARP 模块在协议栈中的位置（FPGA / SoC 场景） # +-------------------+ | 应用层/上层逻辑 | +-------------------+ | UDP/TCP | +-------------------+ | IP | +-------------------+ | ARP 解析模块 | \u0026lt;--- 本文 Verilog 实现部分 +-------------------+ | MAC/PHY | +-------------------+ 3. ARP 报文格式（以太网 + IPv4 场景） # ARP 报文封装在以太网帧中，EtherType = 0x0806。\n3.1 以太网封装 # +----------------------+------------------+ | 前导码 Preamble | 7 字节（0x55...） | +----------------------+------------------+ | SFD (Start Frame Del)| 1 字节（0xD5） | +----------------------+------------------+ | 目的 MAC 地址 | 6 字节 | +----------------------+------------------+ | 源 MAC 地址 | 6 字节 | +----------------------+------------------+ | EtherType = 0x0806 | 2 字节 | +----------------------+------------------+ | ARP 负载 | 28 字节（IPv4） | +----------------------+------------------+ | 填充 Padding | 18 字节（使有效数据≥46）| +----------------------+------------------+ | FCS (CRC32) | 4 字节 | +----------------------+------------------+ 说明：\n以太网要求 MAC 头之后的有效数据 ≥ 46 字节，ARP 负载只有 28 字节，所以需要再填充 18 字节。 前导码 + SFD 由 MAC/PHY 在物理层发送，一般在 MAC 上层是看不到的。 FCS 同样通常由 MAC 计算/校验，上层模块只看到“去掉 FCS 的帧”。 3.2 ARP 报文字段（IPv4 \u0026amp; 以太网） # 字段名 长度（字节） 示例值 描述 Hardware Type (HTYPE) 2 0x0001 硬件类型：以太网为 1 Protocol Type (PTYPE) 2 0x0800 协议类型：IPv4 为 0x0800 Hardware Size (HLEN) 1 0x06 硬件地址长度：MAC 长度 6 Protocol Size (PLEN) 1 0x04 协议地址长度：IPv4 长度 4 Operation (OPER) 2 0x0001/2 1 = 请求，2 = 应答 Sender MAC Address 6 发送端 MAC Sender IP Address 4 发送端 IP Target MAC Address 6 目标 MAC（请求时通常为 0） Target IP Address 4 目标 IP 典型 ARP 帧结构示意图（占位图）：\n4. 整体框架 arp_top.v # 4.1 描述 # arp_top 是 ARP 协议处理的顶层模块，与 MAC 接口相连，对上层提供简化的 ARP 请求/应答接口。 模块主要功能包括：\n从以太网接收方向解析 ARP 帧，对本机 IP 的 ARP 请求做出应答 处理上层发起的 ARP 请求（查询指定 IP 的 MAC 地址） 维护简单的 ARP 缓存表（可选） 典型状态机划分示意：\n状态名 描述 IDLE 空闲，等待接收 ARP 帧或上层 ARP 查询请求 RX_PARSE 从 MAC 接收方向解析 ARP 报文字段 RX_HANDLE 判断是否为发往本机的 ARP 请求，准备应答 TX_REPLY 构造 ARP Reply 帧并从 MAC 发送 TX_REQ 构造 ARP Request 帧并从 MAC 发送 UPDATE 更新 ARP 缓存表 4.2 接口定义 # 信号名 方向 描述 clk 输入 系统时钟 rst_n 输入 复位信号，低有效 local_mac[47:0] 输入 本机 MAC 地址 local_ip[31:0] 输入 本机 IPv4 地址 rx_din[\u0026hellip;] 输入 来自 MAC 的接收数据总线（如 AXI-S/GMII） rx_din_valid 输入 接收数据有效标志 tx_dout[\u0026hellip;] 输出 发送给 MAC 的数据总线 tx_dout_valid 输出 发送数据有效标志 arp_req_ip[31:0] 输入 上层发起的 ARP 查询目标 IP arp_req_valid 输入 ARP 查询请求有效 arp_rsp_mac[47:0] 输出 查询结果 MAC 地址 arp_rsp_valid 输出 查询结果有效 arp_hit 输出 ARP 缓存命中标志 4.3 实现框图占位 # 说明： arp_top 内部可进一步拆分为 arp_rx（接收解析）、arp_tx（发送构造）、arp_cache（缓存表）等子模块。\n4.4 参考 Verilog 框架 # module arp_top #( parameter DATA_WIDTH = 8 )( input clk, input rst_n, input [47:0] local_mac, input [31:0] local_ip, // RX from MAC input [DATA_WIDTH-1:0] rx_din, input rx_din_valid, // TX to MAC output reg [DATA_WIDTH-1:0] tx_dout, output reg tx_dout_valid, // ARP request from upper layer input [31:0] arp_req_ip, input arp_req_valid, output reg [47:0] arp_rsp_mac, output reg arp_rsp_valid, output reg arp_hit ); // 内部信号与状态机定义 // TODO: 在此处补充状态机、字段解析与发送逻辑 endmodule 5. ARP 接收解析模块 arp_rx.v # 5.1 描述 # arp_rx 模块负责从 MAC 接收方向解析 ARP 报文，提取关键字段并上报给上层或 arp_tx 模块。\n5.2 接口示例 # 信号名 方向 描述 clk 输入 时钟 rst_n 输入 复位 rx_din 输入 MAC 接收数据 rx_din_valid 输入 数据有效 rx_arp_valid 输出 指示解析到一完整 ARP 帧 rx_sender_mac 输出 报文中 Sender MAC rx_sender_ip 输出 报文中 Sender IP rx_target_mac 输出 报文中 Target MAC rx_target_ip 输出 报文中 Target IP rx_is_request 输出 是否为 ARP Request rx_is_reply 输出 是否为 ARP Reply 5.3 状态机示例 # localparam S_IDLE = 3\u0026#39;d0; localparam S_HDR = 3\u0026#39;d1; localparam S_PAYLOAD = 3\u0026#39;d2; localparam S_DONE = 3\u0026#39;d3; // TODO: 在此处实现字段计数、字节对齐以及字段装配逻辑 6. ARP 发送构造模块 arp_tx.v # 6.1 描述 # arp_tx 模块负责根据输入信息构造 ARP Request 或 ARP Reply 报文，并通过 MAC 接口发送出去。\n6.2 接口示例 # 信号名 方向 描述 clk 输入 时钟 rst_n 输入 复位 local_mac[47:0] 输入 本机 MAC local_ip[31:0] 输入 本机 IP tx_start_request 输入 触发发送 ARP Request tx_start_reply 输入 触发发送 ARP Reply target_ip[31:0] 输入 请求或应答中的目标 IP target_mac[47:0] 输入 应答中的目标 MAC（通常为对端） tx_dout[\u0026hellip;] 输出 发送数据 tx_dout_valid 输出 数据有效 tx_done 输出 报文发送完成 6.3 构造报文伪代码（逻辑思路） # // 伪代码思路： // 1. 输出以太网头：Dst MAC、Src MAC、EtherType // 2. 输出 ARP 固定头字段：HTYPE/PTYPE/HLEN/PLEN/OPER // 3. 输出 Sender MAC/IP、Target MAC/IP // 4. 置位 tx_done 7. ARP 缓存模块 arp_cache.v（可选） # 7.1 描述 # arp_cache 用于缓存最近解析到的 IP → MAC 映射，减少频繁的 ARP Request。\n7.2 功能要点 # 支持插入/更新 ARP 条目（来自接收方向或上层配置） 支持按 IP 查询（命中则返回 MAC） 支持简单替换策略（如 FIFO / LRU 简化版） 7.3 简单表结构示例 # 条目索引 IP 地址 MAC 地址 有效位 老化计数 0 192.168.1.1 00:11:22:33:44:55 1 10 1 192.168.1.10 AA:BB:CC:DD:EE:FF 1 3 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; 8. 仿真与调试建议 # 功能仿真：\n构造 ARP Request 输入帧，检查 arp_rx 是否正确解析字段 检查 arp_tx 生成的 Request/Reply 帧格式是否符合预期 仿真 ARP 缓存命中/未命中场景 硬件调试：\n用 Wireshark 抓包 ARP 报文，核对帧内容与 FPGA 生成的一致性 观察广播 ARP 请求是否遍历交换机端口 检查对端设备是否正确回应 ARP 示例抓包图占位：\n9. 参考资料 # RFC 826 — An Ethernet Address Resolution Protocol 各操作系统 ARP 命令文档（如 arp -a、ip neigh） 常用网络教材相关章节（ARP/以太网/IPv4） ","date":"6 novembre 2025","externalUrl":null,"permalink":"/docs/arp/","section":"Docs","summary":"\u003ch1 class=\"relative group\"\u003eARP 协议介绍\n    \u003cdiv id=\"arp-协议介绍\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#arp-%e5%8d%8f%e8%ae%ae%e4%bb%8b%e7%bb%8d\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e\u003cbr\u003e\n本文是一个用于介绍 \u003cstrong\u003eARP（Address Resolution Protocol，地址解析协议）\u003c/strong\u003e 的 Verilog 模块示例框架文档。\u003cbr\u003e\n你可以在此基础上增删内容、替换图片和表格数据，作为工程文档或学习笔记使用。\u003c/p\u003e","title":"ARP 协议介绍","type":"docs"},{"content":"","date":"6 novembre 2025","externalUrl":null,"permalink":"/docs/","section":"Docs","summary":"","title":"Docs","type":"docs"},{"content":"","date":"6 novembre 2025","externalUrl":null,"permalink":"/tags/fpga/","section":"Tags","summary":"","title":"FPGA","type":"tags"},{"content":"","date":"6 novembre 2025","externalUrl":null,"permalink":"/tags/ipv4/","section":"Tags","summary":"","title":"IPv4","type":"tags"},{"content":"","date":"6 novembre 2025","externalUrl":null,"permalink":"/tags/verilog/","section":"Tags","summary":"","title":"Verilog","type":"tags"},{"content":"","date":"6 novembre 2025","externalUrl":null,"permalink":"/tags/%E4%BB%A5%E5%A4%AA%E7%BD%91/","section":"Tags","summary":"","title":"以太网","type":"tags"},{"content":"Bilinear interpolation 是一种在嵌入式和 FPGA 上都很实用的图像缩放方法。\n每个输出像素由源图像中最近的四个像素加权平均得到，比最近邻平滑得多，又比高阶滤波器便宜很多。\n本篇主要讲数学和坐标映射；下一篇会对应 Verilog 架构和实现。\n1. 坐标映射：输出像素来自源图像的哪里？ # 设原图尺寸为 w × h，目标图尺寸为 new_w × new_h。则缩放因子为：\n水平方向：scale_x = w / new_w 垂直方向：scale_y = h / new_h 对目标图中整数坐标 (i, j)（0-based），映射到源图中的连续坐标 (src_x, src_y)：\nsrc_x = (i + 0.5) * scale_x - 0.5 src_y = (j + 0.5) * scale_y - 0.5 +0.5 与 -0.5 的作用是让像素中心对齐：当缩放比例为 1× 时，输出图像不会整体平移。([1 Bit FPGA][1])\n接着将连续坐标拆分为整数部分与小数部分：\nx_int = floor(src_x) y_int = floor(src_y) a_x = src_x - x_int // 0..1 a_y = src_y - y_int // 0..1 四个相邻的整数栅格点分别是：\nQ11 = (x_int, y_int) Q21 = (x_int + 1, y_int) Q12 = (x_int, y_int + 1) Q22 = (x_int + 1, y_int + 1) 2. 两种等价的插值公式 # 设灰度值或某个颜色通道的值记为 f(·)。\n2.1 先横向后纵向的两步线性插值（LERP） # 水平方向插值： f(x, y_int) = (1 - a_x) * f(Q11) + a_x * f(Q21) f(x, y_int + 1) = (1 - a_x) * f(Q12) + a_x * f(Q22) 垂直方向插值： I(x, y) = (1 - a_y) * f(x, y_int) + a_y * f(x, y_int + 1) 2.2 一步完成的加权和公式 # 把上下两步合并，可写成四个点的加权和：([1 Bit FPGA][1])\nI(x, y) = (1 - a_x) * (1 - a_y) * f(Q11) + a_x * (1 - a_y) * f(Q21) + (1 - a_x) * a_y * f(Q12) + a_x * a_y * f(Q22) 在 RGB 图像中，对 R/G/B 三个通道分别独立应用同样的插值权重即可。\n3. 示例：4×4 放大到 8×8（单通道） # 原始 4×4 像素值示例：\n10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 目标是放大为 8 × 8，因此缩放因子为：\nscale_x = scale_y = 4 / 8 = 0.5 考虑目标图上像素 (i, j) = (1, 1)：\n映射回源图坐标： src_x = (1 + 0.5) * 0.5 - 0.5 = 0.25 src_y = (1 + 0.5) * 0.5 - 0.5 = 0.25 x_int = 0, y_int = 0 a_x = 0.25 a_y = 0.25 查找四个邻点及其值： Q11 = (0, 0) -\u0026gt; 10 Q21 = (1, 0) -\u0026gt; 20 Q12 = (0, 1) -\u0026gt; 50 Q22 = (1, 1) -\u0026gt; 60 两步插值计算： f(x, y_int) = 0.75 * 10 + 0.25 * 20 = 12.5 f(x, y_int + 1) = 0.75 * 50 + 0.25 * 60 = 52.5 I(x, y) = 0.75 * 12.5 + 0.25 * 52.5 = 22.5 实际图像中，会再根据约定进行取整，例如向最近整数四舍五入，得到 22 或 23。([1 Bit FPGA][1])\n4. 对矩阵进行双线性插值的 Python 示例 # 下面是一个使用 NumPy 实现双线性插值的示例函数，用于将任意大小的 2D 数组缩放到新尺寸。代码思路与文中示例一致，但变量命名和注释略有调整，便于直接复用在工程中。\nimport numpy as np def bilinear_interpolation(input_matrix: np.ndarray, new_shape): \u0026#34;\u0026#34;\u0026#34; Resize a 2D matrix using bilinear interpolation. input_matrix: 2D numpy array, shape (src_h, src_w) new_shape: tuple (dst_h, dst_w) \u0026#34;\u0026#34;\u0026#34; src_h, src_w = input_matrix.shape dst_h, dst_w = new_shape output = np.zeros((dst_h, dst_w), dtype=float) # 注意：这里使用 (N-1)/(M-1) 的写法，可以保证首尾像素对齐 scale_x = (src_w - 1) / (dst_w - 1) if dst_w \u0026gt; 1 else 0.0 scale_y = (src_h - 1) / (dst_h - 1) if dst_h \u0026gt; 1 else 0.0 for i in range(dst_h): for j in range(dst_w): # 映射到源图连续坐标（以像素中心为基准） src_x = (j + 0.5) * scale_x - 0.5 src_y = (i + 0.5) * scale_y - 0.5 x0 = int(np.floor(src_x)) y0 = int(np.floor(src_y)) x1 = min(x0 + 1, src_w - 1) y1 = min(y0 + 1, src_h - 1) wx = src_x - x0 wy = src_y - y0 # 四个点加权求和 v00 = input_matrix[y0, x0] v10 = input_matrix[y0, x1] v01 = input_matrix[y1, x0] v11 = input_matrix[y1, x1] output[i, j] = ( v00 * (1 - wx) * (1 - wy) + v10 * wx * (1 - wy) + v01 * (1 - wx) * wy + v11 * wx * wy ) return output 你可以用文中的 4×4 示例矩阵验证：\ninput_matrix = np.array([ [10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160], ]) output_matrix = bilinear_interpolation(input_matrix, (8, 8)) print(output_matrix) ","date":"31 agosto 2025","externalUrl":null,"permalink":"/docs/hello-world/","section":"Docs","summary":"\u003cp\u003eBilinear interpolation 是一种在嵌入式和 FPGA 上都很实用的图像缩放方法。\u003cbr\u003e\n每个输出像素由源图像中最近的四个像素加权平均得到，比最近邻平滑得多，又比高阶滤波器便宜很多。\u003c/p\u003e","title":"Bilinear Image Scaling in Verilog: Bilinear Interpolation Explanation","type":"docs"},{"content":"","date":"31 agosto 2025","externalUrl":null,"permalink":"/tags/bilinear-verilog/","section":"Tags","summary":"","title":"Bilinear Verilog","type":"tags"},{"content":"","date":"31 agosto 2025","externalUrl":null,"permalink":"/tags/bilinear-image-scaling/","section":"Tags","summary":"","title":"Bilinear-Image-Scaling","type":"tags"},{"content":"","date":"31 agosto 2025","externalUrl":null,"permalink":"/tags/mdio-verilog/","section":"Tags","summary":"","title":"Mdio Verilog","type":"tags"},{"content":" MDIO 接口介绍 # 说明：\n本文是一个用于介绍 MDIO（Management Data Input/Output）接口 的YT8531的verilog模块示例。\n你可以在此基础上增删内容、替换图片和表格数据，作为项目文档或学习笔记使用。\n1. 概述（Overview） # MDIO（Management Data Input/Output） 是以太网中用于访问 PHY（物理层芯片）内部寄存器的管理总线接口。 通常由 MAC 或专用管理控制器作为主机，通过 MDIO 对多个 PHY 进行配置和状态读取。\n标准来源：IEEE 802.3（Clause 22 / Clause 45） 常见应用场景： 千兆/百兆以太网 PHY 配置 链路状态监控（Link up/down、速度、双工等） 调试与寄存器读写 2. MDIO 信号与基本连接 # 2.1 主从拓扑结构 # 典型连接结构如图所示：\n+-----------+ +---------+ | MAC/FPGA | | PHY #0 | |-----------| MDC |---------| | MDIO ----+----------\u0026gt;| MDIO | | MDC -------------+--\u0026gt;| MDC | +-----------+ | +---------+ | | +---------+ +--\u0026gt;| PHY #1 | |---------| | MDIO | | MDC | +---------+ 说明：\n主设备：MAC / FPGA / SoC 内部的 MDIO 控制器 从设备：一个或多个 PHY 芯片 所有 PHY 共用同一条 MDIO/MDC 线，通过不同 PHY 地址区分 2.2 信号定义 # 信号名 方向（相对主机） 描述 MDC 输出 管理总线时钟，典型 \u0026lt; 2.5 MHz MDIO 双向 管理数据线，开漏/三态共享总线 GND - 参考地 VCC - 供电（与 PHY 规格相关） 3. 帧格式（Clause 22 为例） # 3.1 MDIO 帧结构 # Clause 22 标准下，一帧 MDIO 报文结构如下（写/读命令略有差异）：\nPreamble ST OP PHYAD REGAD TA Data (16 bits) 32\u0026rsquo;hffff_ffff 01 10/01 5bit 5bit 2bit 16bit 典型帧结构如图所示： 4. 整体框架 mdio_top.v # 4.1 描述 # 根据芯片手册，MDIO 接口的 MDC 时钟一般不超过 12.5 MHz。本设计中由系统时钟分频得到约 10 MHz 的时钟，作为 MDIO 读写时序的驱动时钟，保证满足各类 PHY 芯片对 MDC 的时序要求。\nmdio_top 模块内部采用有限状态机（FSM）控制 MDIO 总线时序，完整的一次访问大致分为 8 个状态：空闲、前导码发送、起始帧、操作码、地址段、周转段以及数据读写段。各状态功能如下表所示：\nstate 描述 IDLE 空闲状态，等待 start_sig 触发新的 MDIO 访问 PRE 发送一串连续的前导码（通常为 32 个 “1”），唤醒 MDIO 总线 ST 发送起始帧（Start），标识一次 MDIO 访问的开始 OP 发送操作码字段（OP），指示本次为读操作还是写操作 ADDR 依次发送 PHY 地址和寄存器地址字段 TA 周转（Turn Around）状态，控制 MDIO 方向的切换 W_DATA 写数据状态，按位在 MDIO 线上发送 16 位写入数据 R_DATA 读数据状态，从 MDIO 总线上按位采集 16 位读出数据 4.1 mdio_top接口 # 信号名 方向 描述 clk 输入 系统时钟 rst_n 输入 复位信号 rst_n_key 输入 硬复位 led 输出 速率指示灯 mdio 双向 数据线 mdc 输出 时钟线 4.1 实现 # mdio_top模块是顶层模块，由mdio_wr模块、mdio_ctrl模块、以及pll锁相环模块组成。\nmdio_wr模块是核心模块，主要作用是与PHY芯片通信，mdio_ctrl模块用来控制mdio_wr模块，给它不同的地址与命令\nmodule mdio_top( input clk, input rst_n, input rst_n_key, output [1:0] led, // MDIO Interface inout mdio, output mdc ); wire mdio_ack; wire [15:0] mdio_rd_data; wire mdio_wr_done; wire start_sig; wire [1:0] opt; wire [4:0] phy_addr; wire [4:0] reg_addr; wire [1:0] ta; wire [15:0] wr_data; wire clk_out1; clk_wiz_0 instance_name ( // Clock out ports .clk_out1(clk_out1), // output clk_out1 // Status and control signals .resetn(rst_n), // input resetn // Clock in ports .clk_in1(clk)); // input clk_in1 mdio_ctrl u_mdio_ctrl ( .clk (clk_out1), .rst_n (rst_n), .rst_n_key (rst_n_key), .mdio_ack (mdio_ack), // = mdio_rd_ask .mdio_rd_data (mdio_rd_data), .mdio_wr_done (mdio_wr_done), .led (led), .start_sig (start_sig), .opt (opt), .phy_addr (phy_addr), .reg_addr (reg_addr), .ta (ta), .wr_data (wr_data) ); mdio_wr u_mdio_wr ( .clk (clk_out1), .rst_n (rst_n), // Inputs from ctrl .start_sig (start_sig), .opt (opt), .phy_addr (phy_addr), .reg_addr (reg_addr), .ta (ta), .wr_data (wr_data), // Outputs back to ctrl .mdio_rd_data (mdio_rd_data), .mdio_wr_done (mdio_wr_done), .mdio_rd_ask (mdio_ack), // MDIO PHY interface .mdio (mdio), .mdc (mdc) ); endmodule 4.2 MDIO的读写模块mdio_wr.v # 4.2.1 描述 # mdio核心模块，与PHY直接通信，相当于一个配置PHY芯片通信模块。\n4.2.2 接口 # 信号名 方向 描述 clk 输入 系统时钟 rst_n 输入 复位信号，低有效 start_sig 输入 访问开始信号 opt[1:0] 输入 操作类型选择（如读/写） phy_addr[4:0] 输入 PHY 设备地址 reg_addr[4:0] 输入 寄存器地址 ta[1:0] 输入 TA 周转位配置 wr_data[15:0] 输入 待写入 MDIO 的 16 位数据 mdio_rd_data[15:0] 输出 从 MDIO 读出的 16 位数据 mdio_wr_done 输出 MDIO 访问完成标志 mdio_rd_ask 输出 MDIO 读请求指示信号 mdio 双向 MDIO 数据线 mdc 输出 MDIO 时钟线 4.2.2 实现 # module mdio_wr( input clk, input rst_n, // Inputs input start_sig, input [1:0] opt, input [4:0] phy_addr, input [4:0] reg_addr, input [1:0] ta, input [15:0] wr_data, // Outputs output [15:0] mdio_rd_data, output mdio_wr_done, output mdio_rd_ask, // MDIO Interface inout mdio, output mdc ); localparam IDLE = 8\u0026#39;b0000_0001; localparam PRE = 8\u0026#39;b0000_0010; localparam ST = 8\u0026#39;b0000_0100; localparam OP = 8\u0026#39;b0000_1000; localparam ADDR = 8\u0026#39;b0001_0000; localparam TA = 8\u0026#39;b0010_0000; localparam W_DATA = 8\u0026#39;b0100_0000; localparam R_DATA = 8\u0026#39;b1000_0000; reg [7:0] cur_state ; reg [7:0] next_state; reg start_sig_r; reg [1:0] opt_r; reg [4:0] phy_addr_r; reg [4:0] reg_addr_r; reg [1:0] ta_r; reg [15:0] wr_data_r; reg mdio_rd_ask_int; reg [15:0] mdio_rd_data_int; reg mdio_wr_done_int; // mdc clk reg [5:0] clk_cnt; reg mdc_int; reg clk_12_5m; always @ (posedge clk or negedge rst_n) begin if (!rst_n) begin clk_cnt \u0026lt;= 6\u0026#39;b0; clk_12_5m \u0026lt;= 1\u0026#39;b0; end else if (clk_cnt == 6\u0026#39;d1) begin clk_12_5m \u0026lt;= !clk_12_5m; clk_cnt \u0026lt;= 6\u0026#39;b0; end else begin clk_12_5m \u0026lt;= clk_12_5m; clk_cnt \u0026lt;= clk_cnt + 1\u0026#39;b1; end end // mdio timing cnt reg [6:0] mdio_bit_cnt; reg state_done; // mdio inout reg mdio_out; reg mdio_en; wire mdio_in; assign mdio = mdio_en ? mdio_out : 1\u0026#39;bz; assign mdio_in = mdio; always @ (posedge clk_12_5m or negedge rst_n) begin if (!rst_n) begin start_sig_r \u0026lt;= 1\u0026#39;b0; opt_r \u0026lt;= 2\u0026#39;b0; phy_addr_r \u0026lt;= 5\u0026#39;b0; reg_addr_r \u0026lt;= 5\u0026#39;b0; ta_r \u0026lt;= 2\u0026#39;b0; wr_data_r \u0026lt;= 16\u0026#39;b0; end else begin start_sig_r \u0026lt;= start_sig; opt_r \u0026lt;= opt; phy_addr_r \u0026lt;= phy_addr; reg_addr_r \u0026lt;= reg_addr; ta_r \u0026lt;= ta; wr_data_r \u0026lt;= wr_data; end end always @ (posedge clk_12_5m or negedge rst_n) begin if (!rst_n) cur_state \u0026lt;= IDLE; else cur_state \u0026lt;= next_state; end always @ (*) begin next_state = IDLE; case(cur_state) IDLE: if(start_sig_r) next_state = PRE; else next_state = IDLE; PRE: if(state_done) begin next_state = ST; end else begin next_state = PRE; end ST: if(state_done) begin next_state = OP; end else begin next_state = ST; end OP: if(state_done) begin next_state = ADDR; end else begin next_state = OP; end ADDR: if(state_done) begin next_state = TA; end else begin next_state = ADDR; end TA: if(state_done \u0026amp;\u0026amp; (opt_r == 2\u0026#39;b01)) begin next_state = W_DATA; end else if(state_done \u0026amp;\u0026amp; (opt_r == 2\u0026#39;b10)) begin next_state = R_DATA; end else begin next_state = TA; end W_DATA: if(state_done) begin next_state = IDLE; end else begin next_state = W_DATA; end R_DATA: if(state_done) begin next_state = IDLE; end else begin next_state = R_DATA; end default: begin next_state = IDLE; end endcase end always @ (posedge clk_12_5m or negedge rst_n) begin if (!rst_n) begin mdc_int \u0026lt;= 1\u0026#39;b1; mdio_en \u0026lt;= 1\u0026#39;b0; mdio_out \u0026lt;= 1\u0026#39;b1; mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; mdio_rd_ask_int \u0026lt;= 1\u0026#39;b1; mdio_rd_data_int \u0026lt;= 16\u0026#39;b0; mdio_wr_done_int \u0026lt;= 1\u0026#39;b0; end else begin case(cur_state) IDLE: begin mdc_int \u0026lt;= 1\u0026#39;b1; mdio_en \u0026lt;= 1\u0026#39;b0; mdio_out \u0026lt;= 1\u0026#39;b1; mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; mdio_rd_ask_int \u0026lt;= 1\u0026#39;b1; mdio_wr_done_int \u0026lt;= 1\u0026#39;b0; end PRE: begin mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d63) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt \u0026lt; 7\u0026#39;d63) begin mdio_out \u0026lt;= 1\u0026#39;b1; end else begin mdio_out \u0026lt;= 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d62) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end end ST: begin mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d3) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d2) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= 1\u0026#39;b0; // Start bit 7\u0026#39;d2: mdio_out \u0026lt;= 1\u0026#39;b1; // ST bit default: ; endcase end OP: begin mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d3) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;d0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d2) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end if(opt_r == 2\u0026#39;b01) begin // Write operation case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= opt_r[1]; // 1 bit 7\u0026#39;d2: mdio_out \u0026lt;= opt_r[0]; // 2 bit default: ; endcase end else if(opt_r == 2\u0026#39;b10) begin // Read operation case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= opt_r[1]; // 1 bit 7\u0026#39;d2: mdio_out \u0026lt;= opt_r[0]; // 2 bit default: ; endcase end end ADDR: begin // PHY address and Register address mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d19) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;d0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d18) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= phy_addr_r[4]; // PHY address bit 0 7\u0026#39;d2: mdio_out \u0026lt;= phy_addr_r[3]; // PHY address bit 1 7\u0026#39;d4: mdio_out \u0026lt;= phy_addr_r[2]; // PHY address bit 2 7\u0026#39;d6: mdio_out \u0026lt;= phy_addr_r[1]; // PHY address bit 3 7\u0026#39;d8: mdio_out \u0026lt;= phy_addr_r[0]; // PHY address bit 4 7\u0026#39;d10: mdio_out \u0026lt;= reg_addr_r[4]; // Register address bit 0 7\u0026#39;d12: mdio_out \u0026lt;= reg_addr_r[3]; // Register address bit 1 7\u0026#39;d14: mdio_out \u0026lt;= reg_addr_r[2]; // Register address bit 2 7\u0026#39;d16: mdio_out \u0026lt;= reg_addr_r[1]; // Register address bit 3 7\u0026#39;d18: mdio_out \u0026lt;= reg_addr_r[0]; // Register address bit 4 default: ; endcase end TA: begin // Turnaround mdc_int \u0026lt;= ~mdc_int; if (mdio_bit_cnt == 7\u0026#39;d3) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;d0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d2) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end if(opt_r == 2\u0026#39;b01) begin // Write operation mdio_en \u0026lt;= 1\u0026#39;b1; case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= 1\u0026#39;b1; // 1 bit 7\u0026#39;d2: mdio_out \u0026lt;= 1\u0026#39;b0; // 2 bit default: ; endcase end else if(opt_r == 2\u0026#39;b10) begin // Read operation mdio_out \u0026lt;= 1\u0026#39;b1; mdio_en \u0026lt;= 1\u0026#39;b0; case(mdio_bit_cnt) 7\u0026#39;d0: ; // 1 bit 7\u0026#39;d2: mdio_rd_ask_int \u0026lt;= mdio_in; // 2 bit default: ; endcase end end W_DATA: begin // Write data to MDIO mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d32) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d31) begin state_done \u0026lt;= 1\u0026#39;b1; mdio_wr_done_int \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; mdio_wr_done_int \u0026lt;= 1\u0026#39;b0; end case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= wr_data_r[15]; // 7\u0026#39;d2: mdio_out \u0026lt;= wr_data_r[14]; // 7\u0026#39;d4: mdio_out \u0026lt;= wr_data_r[13]; // 7\u0026#39;d6: mdio_out \u0026lt;= wr_data_r[12]; // 7\u0026#39;d8: mdio_out \u0026lt;= wr_data_r[11]; // 7\u0026#39;d10: mdio_out \u0026lt;= wr_data_r[10]; // 7\u0026#39;d12: mdio_out \u0026lt;= wr_data_r[9]; // 7\u0026#39;d14: mdio_out \u0026lt;= wr_data_r[8]; // 7\u0026#39;d16: mdio_out \u0026lt;= wr_data_r[7]; // 7\u0026#39;d18: mdio_out \u0026lt;= wr_data_r[6]; // 7\u0026#39;d20: mdio_out \u0026lt;= wr_data_r[5]; // 7\u0026#39;d22: mdio_out \u0026lt;= wr_data_r[4]; // 7\u0026#39;d24: mdio_out \u0026lt;= wr_data_r[3]; // 7\u0026#39;d26: mdio_out \u0026lt;= wr_data_r[2]; // 7\u0026#39;d28: mdio_out \u0026lt;= wr_data_r[1]; // 7\u0026#39;d30: mdio_out \u0026lt;= wr_data_r[0]; // 7\u0026#39;d32: mdio_out \u0026lt;= 1\u0026#39;b1; // default: ; endcase end R_DATA: begin // Read data from MDIO mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b0; if (mdio_bit_cnt == 7\u0026#39;d31) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d30) begin state_done \u0026lt;= 1\u0026#39;b1; mdio_wr_done_int \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; mdio_wr_done_int \u0026lt;= 1\u0026#39;b0; end case(mdio_bit_cnt) 7\u0026#39;d0: mdio_rd_data_int[15] \u0026lt;= mdio_in; // 7\u0026#39;d2: mdio_rd_data_int[14] \u0026lt;= mdio_in; // 7\u0026#39;d4: mdio_rd_data_int[13] \u0026lt;= mdio_in; // 7\u0026#39;d6: mdio_rd_data_int[12] \u0026lt;= mdio_in; // 7\u0026#39;d8: mdio_rd_data_int[11] \u0026lt;= mdio_in; // 7\u0026#39;d10: mdio_rd_data_int[10] \u0026lt;= mdio_in; // 7\u0026#39;d12: mdio_rd_data_int[9] \u0026lt;= mdio_in; // 7\u0026#39;d14: mdio_rd_data_int[8] \u0026lt;= mdio_in; // 7\u0026#39;d16: mdio_rd_data_int[7] \u0026lt;= mdio_in; // 7\u0026#39;d18: mdio_rd_data_int[6] \u0026lt;= mdio_in; // 7\u0026#39;d20: mdio_rd_data_int[5] \u0026lt;= mdio_in; // 7\u0026#39;d22: mdio_rd_data_int[4] \u0026lt;= mdio_in; // 7\u0026#39;d24: mdio_rd_data_int[3] \u0026lt;= mdio_in; // 7\u0026#39;d26: mdio_rd_data_int[2] \u0026lt;= mdio_in; // 7\u0026#39;d28: mdio_rd_data_int[1] \u0026lt;= mdio_in; // 7\u0026#39;d30: mdio_rd_data_int[0] \u0026lt;= mdio_in; // default: ; endcase end default : ; endcase end end assign mdio_rd_ask = mdio_rd_ask_int; assign mdio_rd_data = mdio_rd_data_int; assign mdc = mdc_int; assign mdio_wr_done = mdio_wr_done_int; endmodule 4.3 MDIO的控制模块mdio_ctrl.v # 4.3.1 描述 # MDIO的控制模块，控制mdio_wr模块。\n4.3.2 接口 # module mdio_ctrl( input clk, input rst_n, input rst_n_key,\ninput mdio_ack,\rinput [15:0] mdio_rd_data,\rinput mdio_wr_done,\routput [1:0] led,\routput start_sig,\routput [1:0] opt,\routput [4:0] phy_addr,\routput [4:0] reg_addr,\routput [1:0] ta,\routput [15:0] wr_data\r);\n4.3.2 实现 # module mdio_ctrl( input clk, input rst_n, input rst_n_key, input mdio_ack, input [15:0] mdio_rd_data, input mdio_wr_done, output [1:0] led, output start_sig, output [1:0] opt, output [4:0] phy_addr, output [4:0] reg_addr, output [1:0] ta, output [15:0] wr_data ); reg mdio_ack_r; reg [15:0] mdio_rd_data_r; reg mdio_wr_done_r; reg mdio_wr_done_rr; reg [1:0] led_int; reg start_sig_int; reg [1:0] opt_int; reg [4:0] phy_addr_int; reg [4:0] reg_addr_int; reg [1:0] ta_int; reg [15:0] wr_data_int; parameter INIT_TIME_CNT = 24\u0026#39;d5_000_000; reg [23:0] init_timer_cnt; reg init_done; reg rst_n_key_r0; reg rst_n_key_r1; reg rst_n_key_r2; reg rst_key_flag; localparam IDLE = 5\u0026#39;b00001; localparam START = 5\u0026#39;b00010; localparam READ = 5\u0026#39;b00100; localparam WRITE = 5\u0026#39;b01000; localparam READ2 = 5\u0026#39;b10000; reg [4:0] cur_state; reg [4:0] next_state; reg [9:0] state_cnt; reg state_done; reg link_error; reg [1:0] speed_status; always @(posedge clk or negedge rst_n) begin if (!rst_n) begin rst_n_key_r0 \u0026lt;= 1\u0026#39;b0; rst_n_key_r1 \u0026lt;= 1\u0026#39;b0; rst_n_key_r2 \u0026lt;= 1\u0026#39;b0; rst_key_flag \u0026lt;= 1\u0026#39;b0; mdio_ack_r \u0026lt;= 1\u0026#39;b0; mdio_rd_data_r \u0026lt;= 16\u0026#39;b0; mdio_wr_done_r \u0026lt;= 1\u0026#39;b0; mdio_wr_done_rr \u0026lt;= 1\u0026#39;b0; end else begin rst_n_key_r0 \u0026lt;= rst_n_key; rst_n_key_r1 \u0026lt;= rst_n_key_r0; rst_n_key_r2 \u0026lt;= rst_n_key_r1; rst_key_flag \u0026lt;= ~rst_n_key_r2 \u0026amp; rst_n_key_r1; mdio_ack_r \u0026lt;= mdio_ack; mdio_rd_data_r \u0026lt;= mdio_rd_data; mdio_wr_done_r \u0026lt;= mdio_wr_done; mdio_wr_done_rr \u0026lt;= mdio_wr_done_r; end end always @(posedge clk or negedge rst_n) begin if (!rst_n) begin init_timer_cnt \u0026lt;= 24\u0026#39;b0; init_done \u0026lt;= 1\u0026#39;b0; end else if (rst_key_flag) begin init_timer_cnt \u0026lt;= 24\u0026#39;b0; init_done \u0026lt;= 1\u0026#39;b0; end else if (init_timer_cnt == INIT_TIME_CNT - 1) begin init_timer_cnt \u0026lt;= 24\u0026#39;b0; init_done \u0026lt;= 1\u0026#39;b1; end else begin init_done \u0026lt;= 1\u0026#39;b0; init_timer_cnt \u0026lt;= init_timer_cnt + 1\u0026#39;b1; end end always @ (posedge clk or negedge rst_n) begin if (!rst_n) begin cur_state \u0026lt;= IDLE; end else begin if(rst_key_flag) cur_state \u0026lt;= IDLE; else cur_state \u0026lt;= next_state; end end always @ (*) begin case(cur_state) IDLE : begin if (init_done) begin next_state = START; end else begin next_state = IDLE; end end START : begin if (state_done) begin next_state = READ; end else begin next_state = START; end end READ : begin if (!mdio_wr_done_rr \u0026amp;\u0026amp; mdio_wr_done_r) begin next_state = WRITE; end else begin next_state = READ; end end WRITE : begin if (!mdio_wr_done_rr \u0026amp;\u0026amp; mdio_wr_done_r) begin next_state = READ2; end else begin next_state = WRITE; end end READ2 : begin next_state = READ2; end default : begin next_state = IDLE; end endcase end always @ (posedge clk or negedge rst_n) begin if (!rst_n) begin led_int \u0026lt;= 2\u0026#39;b0; start_sig_int \u0026lt;= 1\u0026#39;b0; opt_int \u0026lt;= 2\u0026#39;b0; phy_addr_int \u0026lt;= 5\u0026#39;b0; reg_addr_int \u0026lt;= 5\u0026#39;b0; ta_int \u0026lt;= 2\u0026#39;b0; wr_data_int \u0026lt;= 16\u0026#39;b0; state_cnt \u0026lt;= 10\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; link_error \u0026lt;= 1\u0026#39;b0; speed_status \u0026lt;= 2\u0026#39;b00; end else begin case(cur_state) IDLE : begin led_int \u0026lt;= 2\u0026#39;b00; start_sig_int \u0026lt;= 1\u0026#39;b0; opt_int \u0026lt;= 2\u0026#39;b0; phy_addr_int \u0026lt;= 5\u0026#39;b0; reg_addr_int \u0026lt;= 5\u0026#39;b0; ta_int \u0026lt;= 2\u0026#39;b0; wr_data_int \u0026lt;= 16\u0026#39;b0; state_cnt \u0026lt;= 10\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; speed_status \u0026lt;= 2\u0026#39;b00; link_error \u0026lt;= 1\u0026#39;b0; end START : begin if (state_cnt == 10\u0026#39;d20) begin state_done \u0026lt;= 1\u0026#39;b1; state_cnt \u0026lt;= 10\u0026#39;b0; opt_int \u0026lt;= 2\u0026#39;b10; //read operation phy_addr_int \u0026lt;= 5\u0026#39;d4; //phy address reg_addr_int \u0026lt;= 5\u0026#39;d1; //reg address ta_int \u0026lt;= 2\u0026#39;b10; //turnaround wr_data_int \u0026lt;= 16\u0026#39;h0000; end else begin state_cnt \u0026lt;= state_cnt + 1\u0026#39;b1; state_done \u0026lt;= 1\u0026#39;b0; end end READ : begin if (state_cnt \u0026lt;= 10\u0026#39;d20) begin state_cnt \u0026lt;= state_cnt + 1\u0026#39;b1; end else begin state_cnt \u0026lt;= state_cnt; end if (state_cnt == 10\u0026#39;d2) begin opt_int \u0026lt;= 2\u0026#39;b10; //read operation phy_addr_int \u0026lt;= 5\u0026#39;d4; //phy address reg_addr_int \u0026lt;= 5\u0026#39;h1; //reg address ta_int \u0026lt;= 2\u0026#39;b10; //turnaround wr_data_int \u0026lt;= 16\u0026#39;h0000; end if (state_cnt == 10\u0026#39;d17 || state_cnt == 10\u0026#39;d18 || state_cnt == 10\u0026#39;d19) begin start_sig_int \u0026lt;= 1\u0026#39;b1; end else begin start_sig_int \u0026lt;= 1\u0026#39;b0; end end WRITE : begin if (state_cnt \u0026lt;= 10\u0026#39;d40) begin state_cnt \u0026lt;= state_cnt + 1\u0026#39;b1; end else begin state_cnt \u0026lt;= state_cnt; end if (state_cnt == 10\u0026#39;d22) begin opt_int \u0026lt;= 2\u0026#39;b01; //write operation phy_addr_int \u0026lt;= 5\u0026#39;d4; //phy address reg_addr_int \u0026lt;= 5\u0026#39;d0; //reg address ta_int \u0026lt;= 2\u0026#39;b10; //turnaround wr_data_int \u0026lt;= 16\u0026#39;h9140; end if (state_cnt == 10\u0026#39;d37 || state_cnt == 10\u0026#39;d38 || state_cnt == 10\u0026#39;d39) begin start_sig_int \u0026lt;= 1\u0026#39;b1; end else begin start_sig_int \u0026lt;= 1\u0026#39;b0; end end READ2 : begin if (state_cnt \u0026lt;= 10\u0026#39;d600) begin state_cnt \u0026lt;= state_cnt + 1\u0026#39;b1; end else begin state_cnt \u0026lt;= 10\u0026#39;d0; end if (state_cnt == 10\u0026#39;d42) begin opt_int \u0026lt;= 2\u0026#39;b10; //read operation phy_addr_int \u0026lt;= 5\u0026#39;d4; //phy address reg_addr_int \u0026lt;= 5\u0026#39;h1; //reg address ta_int \u0026lt;= 2\u0026#39;b10; //turnaround wr_data_int \u0026lt;= 16\u0026#39;h0000; end if (state_cnt == 10\u0026#39;d57 || state_cnt == 10\u0026#39;d58 || state_cnt == 10\u0026#39;d59) begin start_sig_int \u0026lt;= 1\u0026#39;b1; end else begin start_sig_int \u0026lt;= 1\u0026#39;b0; end if(mdio_rd_data_r[5] == 1\u0026#39;b1 \u0026amp;\u0026amp; mdio_rd_data_r[2] == 1\u0026#39;b1) link_error \u0026lt;= 1\u0026#39;b0; else link_error \u0026lt;= 1\u0026#39;b1; if(mdio_rd_data_r[15:14] == 2\u0026#39;b10) speed_status \u0026lt;= 2\u0026#39;b11; //1000Mbps else if(mdio_rd_data_r[15:14] == 2\u0026#39;b01) speed_status \u0026lt;= 2\u0026#39;b10; //100Mbps else if(mdio_rd_data_r[15:14] == 2\u0026#39;b00) speed_status \u0026lt;= 2\u0026#39;b01; //10Mbps else speed_status \u0026lt;= 2\u0026#39;b00; //unknown led_int \u0026lt;= link_error ? 2\u0026#39;b00 : mdio_rd_data_r[15:14]; //indicate speed status end default : begin led_int \u0026lt;= 2\u0026#39;b00; start_sig_int \u0026lt;= 1\u0026#39;b0; opt_int \u0026lt;= 2\u0026#39;b0; phy_addr_int \u0026lt;= 5\u0026#39;b0; reg_addr_int \u0026lt;= 5\u0026#39;b0; ta_int \u0026lt;= 2\u0026#39;b0; wr_data_int \u0026lt;= 16\u0026#39;b0; state_cnt \u0026lt;= 10\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; end endcase end end assign led = led_int; assign start_sig = start_sig_int; assign opt = opt_int; assign phy_addr = phy_addr_int; assign reg_addr = reg_addr_int; assign ta = ta_int; assign wr_data = wr_data_int; endmodule ","date":"31 agosto 2025","externalUrl":null,"permalink":"/docs/mdio/","section":"Docs","summary":"\u003ch1 class=\"relative group\"\u003eMDIO 接口介绍\n    \u003cdiv id=\"mdio-接口介绍\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#mdio-%e6%8e%a5%e5%8f%a3%e4%bb%8b%e7%bb%8d\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e\u003cbr\u003e\n本文是一个用于介绍 \u003cstrong\u003eMDIO（Management Data Input/Output）接口\u003c/strong\u003e 的YT8531的verilog模块示例。\u003cbr\u003e\n你可以在此基础上增删内容、替换图片和表格数据，作为项目文档或学习笔记使用。\u003c/p\u003e","title":"MDIO 接口介绍","type":"docs"},{"content":"","date":"31 agosto 2025","externalUrl":null,"permalink":"/tags/phy/","section":"Tags","summary":"","title":"Phy","type":"tags"},{"content":"","date":"31 agosto 2025","externalUrl":null,"permalink":"/tags/phy-verilog/","section":"Tags","summary":"","title":"Phy Verilog","type":"tags"},{"content":"","date":"31 agosto 2025","externalUrl":null,"permalink":"/tags/scaler-verilog/","section":"Tags","summary":"","title":"Scaler Verilog","type":"tags"},{"content":"","date":"31 agosto 2025","externalUrl":null,"permalink":"/tags/video-scaling/","section":"Tags","summary":"","title":"Video Scaling","type":"tags"},{"content":"","externalUrl":null,"permalink":"/it/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/it/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/it/","section":"LANIAKEA","summary":"","title":"LANIAKEA","type":"page"},{"content":"","externalUrl":null,"permalink":"/it/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/it/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]
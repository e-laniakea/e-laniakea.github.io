






[{"content":"","date":"6 November 2025","externalUrl":null,"permalink":"/tags/arp/","section":"Tags","summary":"","title":"ARP","type":"tags"},{"content":" ARP 协议介绍 # 说明：\n本文是一个用于介绍 ARP（Address Resolution Protocol，地址解析协议） 的 Verilog 模块示例框架文档。\n你可以在此基础上增删内容、替换图片和表格数据，作为工程文档或学习笔记使用。\n1. 概述（Overview） # ARP（Address Resolution Protocol） 工作在局域网中，用于将 IPv4 地址解析为链路层（以太网） MAC 地址。\n当主机只知道目标 IP 地址时，通过 ARP 在同一广播域内查询对应的 MAC 地址。\n标准来源：RFC 826 所在层次：一般认为位于二层/三层之间 主要功能： 将 IPv4 地址解析为 MAC 地址 维护 ARP 缓存，减少网络广播 为 IP 协议提供底层地址解析能力 2. ARP 工作原理与基本连接 # 2.1 典型网络拓扑结构 # +----------+ +-----------+ +-----------+ | 主机 A | | 交换机 | | 主机 B | | IP: A |\u0026lt;-----\u0026gt; | / 路由器 |\u0026lt;-----\u0026gt;| IP: B | +----------+ +-----------+ +-----------+ | | | |\u0026lt;------ 同一广播域/二层网络 ----------\u0026gt;| 说明：\n当主机 A 需要给主机 B 发送数据：\n检查本地 ARP 缓存表是否已有 B 的 MAC 如果没有，则广播 ARP 请求 B 单播 ARP 应答给 A A 将解析结果缓存并开始正常发送以太网数据帧 2.2 ARP 模块在协议栈中的位置（FPGA / SoC 场景） # +-------------------+ | 应用层/上层逻辑 | +-------------------+ | UDP/TCP | +-------------------+ | IP | +-------------------+ | ARP 解析模块 | \u0026lt;--- 本文 Verilog 实现部分 +-------------------+ | MAC/PHY | +-------------------+ 3. ARP 报文格式（以太网 + IPv4 场景） # ARP 报文封装在以太网帧中，EtherType = 0x0806。\n3.1 以太网封装 # +----------------------+------------------+ | 前导码 Preamble | 7 字节（0x55...） | +----------------------+------------------+ | SFD (Start Frame Del)| 1 字节（0xD5） | +----------------------+------------------+ | 目的 MAC 地址 | 6 字节 | +----------------------+------------------+ | 源 MAC 地址 | 6 字节 | +----------------------+------------------+ | EtherType = 0x0806 | 2 字节 | +----------------------+------------------+ | ARP 负载 | 28 字节（IPv4） | +----------------------+------------------+ | 填充 Padding | 18 字节（使有效数据≥46）| +----------------------+------------------+ | FCS (CRC32) | 4 字节 | +----------------------+------------------+ 说明：\n以太网要求 MAC 头之后的有效数据 ≥ 46 字节，ARP 负载只有 28 字节，所以需要再填充 18 字节。 前导码 + SFD 由 MAC/PHY 在物理层发送，一般在 MAC 上层是看不到的。 FCS 同样通常由 MAC 计算/校验，上层模块只看到“去掉 FCS 的帧”。 3.2 ARP 报文字段（IPv4 \u0026amp; 以太网） # 字段名 长度（字节） 示例值 描述 Hardware Type (HTYPE) 2 0x0001 硬件类型：以太网为 1 Protocol Type (PTYPE) 2 0x0800 协议类型：IPv4 为 0x0800 Hardware Size (HLEN) 1 0x06 硬件地址长度：MAC 长度 6 Protocol Size (PLEN) 1 0x04 协议地址长度：IPv4 长度 4 Operation (OPER) 2 0x0001/2 1 = 请求，2 = 应答 Sender MAC Address 6 发送端 MAC Sender IP Address 4 发送端 IP Target MAC Address 6 目标 MAC（请求时通常为 0） Target IP Address 4 目标 IP 典型 ARP 帧结构示意图（占位图）：\n4. 整体框架 arp_top.v # 4.1 描述 # arp_top 是 ARP 协议处理的顶层模块，与 MAC 接口相连，对上层提供简化的 ARP 请求/应答接口。 模块主要功能包括：\n从以太网接收方向解析 ARP 帧，对本机 IP 的 ARP 请求做出应答 处理上层发起的 ARP 请求（查询指定 IP 的 MAC 地址） 维护简单的 ARP 缓存表（可选） 4.2 接口定义 # 信号名 方向 位宽 时钟域 说明 rst_n In 1 — 低电平复位，异步或同步视实现而定 gmii_rx_clk In 1 GMII RX 时钟 GMII 接收时钟 gmii_rx_dv In 1 gmii_rx_clk GMII 接收数据有效 gmii_rxd In 8 gmii_rx_clk GMII 接收数据总线 gmii_tx_clk In 1 GMII TX 时钟 GMII 发送时钟 gmii_tx_en Out 1 gmii_tx_clk GMII 发送数据有效 gmii_txd Out 8 gmii_tx_clk GMII 发送数据总线 arp_rx_done Out 1 gmii_rx_clk 一帧 ARP 接收完成脉冲 arp_rx_type Out 1 gmii_rx_clk 接收 ARP 类型：0=请求，1=应答 src_mac Out 48 gmii_rx_clk 接收到的 发送端 MAC 地址 src_ip Out 32 gmii_rx_clk 接收到的 发送端 IP 地址 arp_tx_en In 1 gmii_tx_clk 发送 ARP 使能，上升沿触发发送 arp_tx_type In 1 gmii_tx_clk 发送 ARP 类型：0=请求，1=应答 target_mac In 48 gmii_tx_clk 要查询/应答的目标 MAC（应答时） target_ip In 32 gmii_tx_clk 要查询/应答的目标 IP tx_done Out 1 gmii_tx_clk 一帧 ARP 发送完成脉冲 4.3 实现框图占位 # 说明： arp_top 内部可进一步拆分为 arp_rx（接收解析）、arp_tx（发送构造）、crc32_d8（校验）等子模块。\n4.4 参考 Verilog 框架 # module arp #( parameter FPGA_MAC = 48\u0026#39;h00_11_22_33_44_55, //开发板MAC地址 parameter FPGA_IP = {8\u0026#39;d192,8\u0026#39;d168,8\u0026#39;d1,8\u0026#39;d10}, //开发板IP地址 parameter TARGET_MAC = 48\u0026#39;hff_ff_ff_ff_ff_ff, //目的MAC地址 parameter TARGET_IP = {8\u0026#39;d192,8\u0026#39;d168,8\u0026#39;d1,8\u0026#39;d102}, //目的IP地址 parameter ETH_TYPE = 16\u0026#39;h0806 ) ( input rst_n , //复位信号，低电平有效 //GMII接口 input gmii_rx_clk, //GMII接收数据时钟 input gmii_rx_dv , //GMII输入数据有效信号 input [7:0] gmii_rxd , //GMII输入数据 input gmii_tx_clk, //GMII发送数据时钟 output gmii_tx_en , //GMII输出数据有效信号 output [7:0] gmii_txd , //GMII输出数据 //用户接口 output arp_rx_done, //ARP接收完成信号 output arp_rx_type, //ARP接收类型 0:请求 1:应答 output [47:0] src_mac , //接收到目的MAC地址 output [31:0] src_ip , //接收到目的IP地址 input arp_tx_en , //ARP发送使能信号 input arp_tx_type, //ARP发送类型 0:请求 1:应答 input [47:0] target_mac , //发送的目标MAC地址 input [31:0] target_ip , //发送的目标IP地址 output tx_done //以太网发送完成信号 ); wire crc_en ; wire crc_clr ; wire [31:0] crc_data; wire [31:0] crc_next; wire [7:0] crc_d8; assign crc_d8 = gmii_txd; arp_rx #( .FPGA_MAC(FPGA_MAC), .FPGA_IP(FPGA_IP), .ETH_TYPE(ETH_TYPE) ) arp_rx_inst ( .clk(gmii_rx_clk), .rst_n(rst_n), .gmii_rx_dv(gmii_rx_dv), .gmii_rxd(gmii_rxd), .arp_rx_done(arp_rx_done), .arp_rx_type(arp_rx_type), .src_mac(src_mac), .src_ip(src_ip) ); arp_tx #( .FPGA_MAC(FPGA_MAC), .FPGA_IP(FPGA_IP), .TARGET_MAC(TARGET_MAC), .TARGET_IP(TARGET_IP) ) arp_tx_inst ( .clk(gmii_tx_clk), .rst_n(rst_n), .arp_tx_en(arp_tx_en), .arp_tx_type(arp_tx_type), .target_mac(target_mac), .target_ip(target_ip), .crc_data(crc_data), .crc_next(crc_next[31:24]), .tx_done(tx_done), .gmii_tx_en(gmii_tx_en), .gmii_txd(gmii_txd), .crc_en(crc_en), .crc_clr(crc_clr) ); crc32_d8 u_crc32_d8( .clk (gmii_tx_clk), .rst_n (rst_n), .data (crc_d8), .crc_en (crc_en ), .crc_clr (crc_clr ), .crc_data (crc_data ), .crc_next (crc_next ) ); endmodule 5. ARP 接收解析模块 arp_rx.v # 5.1 描述 # arp_rx 模块负责从 MAC 接收方向解析 ARP 报文，提取关键字段并上报给上层或 arp_tx 模块。\n5.2 接口示例 # 信号名 方向 位宽 时钟域 说明 clk In 1 GMII RX 时钟 与 gmii_rx_clk 相同 rst_n In 1 — 低电平复位 gmii_rx_dv In 1 clk GMII 接收数据有效 gmii_rxd In 8 clk GMII 接收数据总线 arp_rx_done Out 1 clk 一帧 ARP 接收完成脉冲（通过 FCS 状态结束产生） arp_rx_type Out 1 clk 接收 ARP 类型：0=请求(OP=1)，1=应答(OP=2) src_mac Out 48 clk ARP 报文中 Sender MAC（发送端 MAC） src_ip Out 32 clk ARP 报文中 Sender IP（发送端 IP） 5.3 状态机示例 # module arp_rx #( parameter FPGA_MAC = 48\u0026#39;h0000_0000_0000, parameter FPGA_IP = {8\u0026#39;d192,8\u0026#39;d168,8\u0026#39;d1,8\u0026#39;d10}, parameter ETH_TYPE = 16\u0026#39;h0806 ) ( input clk, input rst_n, input gmii_rx_dv, input [7:0] gmii_rxd, output arp_rx_done, output arp_rx_type, output [47:0] src_mac, output [31:0] src_ip ); //parameter define localparam IDLE = 6\u0026#39;b00_0001; //idle state localparam PREAMBLE = 6\u0026#39;b00_0010; //preamble 7 bytes 8\u0026#39;h55 localparam SFD = 6\u0026#39;b00_0100; //sfd 1 byte 8\u0026#39;hd5 localparam ETH_HEAD = 6\u0026#39;b00_1000; //eth head 14 bytes target mac(6) + source mac(6) + eth type(2) localparam ARP_DATA = 6\u0026#39;b01_0000; //arp data 28 bytes hardware type(2) + protocol type(2) + //hardware size(1) + protocol size(1) + opcode(2) + //source mac(6) + source ip(4) + dest mac(6) + dest ip(4) localparam FCS = 6\u0026#39;b10_0000; //fcs 4 bytes reg [5:0] cur_state; reg [5:0] next_state; reg state_done; reg gmii_rx_dv_r; reg [7:0] gmii_rxd_r; reg arp_rx_done_int; reg arp_rx_type_int; reg [47:0] src_mac_int; reg [31:0] src_ip_int; //reg define reg err_en; reg [7:0] rx_cnt;//byte counter,arp have 28 bytes data,so max cnt is 27 is enough reg [31:0] rx_ip_target; reg [31:0] rx_ip_source; reg [15:0] rx_op_type; reg [47:0] rx_mac_target; reg [47:0] rx_mac_source; reg [15:0] rx_eth_type; always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin gmii_rx_dv_r \u0026lt;= 1\u0026#39;b0; gmii_rxd_r \u0026lt;= 8\u0026#39;b0; end else begin gmii_rx_dv_r \u0026lt;= gmii_rx_dv; gmii_rxd_r \u0026lt;= gmii_rxd; end end always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin cur_state \u0026lt;= IDLE; end else begin cur_state \u0026lt;= next_state; end end always @ (*) begin next_state = IDLE; case(cur_state) IDLE: begin if(gmii_rx_dv_r) next_state = PREAMBLE; else next_state = IDLE; end PREAMBLE: begin if(state_done) next_state = SFD; else next_state = PREAMBLE; end SFD: begin next_state = ETH_HEAD; end ETH_HEAD: begin if(state_done) next_state = ARP_DATA; else next_state = ETH_HEAD; end ARP_DATA: begin if(state_done) next_state = FCS; else next_state = ARP_DATA; end FCS: begin if(state_done) next_state = IDLE; else next_state = FCS; end default: begin next_state = IDLE; end endcase end always @ (posedge clk or negedge rst_n) begin if (!rst_n) begin arp_rx_done_int \u0026lt;= 1\u0026#39;b0; arp_rx_type_int \u0026lt;= 1\u0026#39;b0; src_mac_int \u0026lt;= 48\u0026#39;b0; src_ip_int \u0026lt;= 32\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; err_en \u0026lt;= 1\u0026#39;b0; rx_cnt \u0026lt;= 8\u0026#39;b0; rx_ip_target \u0026lt;= 32\u0026#39;b0; rx_ip_source \u0026lt;= 32\u0026#39;b0; rx_op_type \u0026lt;= 16\u0026#39;b0; rx_mac_target \u0026lt;= 48\u0026#39;b0; rx_mac_source \u0026lt;= 48\u0026#39;b0; rx_eth_type \u0026lt;= 16\u0026#39;b0; end else begin case(cur_state) IDLE: begin if(gmii_rx_dv_r) begin if( gmii_rxd_r != 8\u0026#39;h55 ) begin err_en \u0026lt;= 1\u0026#39;b1; end else begin err_en \u0026lt;= 1\u0026#39;b0; end rx_cnt \u0026lt;= rx_cnt + 1\u0026#39;b1; end else begin err_en \u0026lt;= 1\u0026#39;b0; end end PREAMBLE : begin if(gmii_rx_dv_r) begin if(gmii_rxd_r == 8\u0026#39;h55) begin err_en \u0026lt;= 1\u0026#39;b0; end else begin err_en \u0026lt;= 1\u0026#39;b1; end end else begin err_en \u0026lt;= 1\u0026#39;b0; end if(rx_cnt == 8\u0026#39;d6 \u0026amp;\u0026amp; gmii_rx_dv_r) begin rx_cnt \u0026lt;= 8\u0026#39;d0; end else begin rx_cnt \u0026lt;= rx_cnt + 1\u0026#39;b1; end if(rx_cnt == 8\u0026#39;d5 \u0026amp;\u0026amp; gmii_rx_dv_r) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end end SFD : begin if(gmii_rx_dv_r \u0026amp;\u0026amp; gmii_rxd_r == 8\u0026#39;hd5) begin err_en \u0026lt;= 1\u0026#39;b0; end else begin err_en \u0026lt;= 1\u0026#39;b1; end state_done \u0026lt;= 1\u0026#39;b0; rx_cnt \u0026lt;= 8\u0026#39;d0; end ETH_HEAD : begin if(gmii_rx_dv_r) begin // Capture target MAC address if(rx_cnt \u0026lt; 8\u0026#39;d6) begin rx_mac_target \u0026lt;= {rx_mac_target[39:0],gmii_rxd_r}; end else begin rx_mac_target \u0026lt;= rx_mac_target; end // Capture source MAC address if(rx_cnt \u0026gt;= 8\u0026#39;d6 \u0026amp;\u0026amp; rx_cnt \u0026lt; 8\u0026#39;d12) begin rx_mac_source \u0026lt;= {rx_mac_source[39:0],gmii_rxd_r}; end else begin rx_mac_source \u0026lt;= rx_mac_source; end // Capture Ethernet type if(rx_cnt \u0026gt;= 8\u0026#39;d12 \u0026amp;\u0026amp; rx_cnt \u0026lt; 8\u0026#39;d14) begin rx_eth_type \u0026lt;= {rx_eth_type[7:0],gmii_rxd_r}; end else begin rx_eth_type \u0026lt;= rx_eth_type; end // Check if((rx_cnt == 8\u0026#39;d6) \u0026amp;\u0026amp; (rx_mac_target != FPGA_MAC) \u0026amp;\u0026amp; (rx_mac_target != 48\u0026#39;hff_ff_ff_ff_ff_ff)) begin err_en \u0026lt;= 1\u0026#39;b1; end else begin err_en \u0026lt;= 1\u0026#39;b0; end end else begin end if(rx_cnt == 8\u0026#39;d13) begin src_mac_int \u0026lt;= rx_mac_source; rx_cnt \u0026lt;= 8\u0026#39;b0; end else begin rx_cnt \u0026lt;= rx_cnt + 1\u0026#39;b1; end // Finish ETH_HEAD state if(rx_cnt == 8\u0026#39;d12) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end end ARP_DATA : begin if(gmii_rx_dv_r) begin // Capture target ip address if(rx_cnt \u0026gt;= 8\u0026#39;d24 \u0026amp;\u0026amp; rx_cnt \u0026lt; 8\u0026#39;d28) begin rx_ip_target \u0026lt;= {rx_ip_target[23:0],gmii_rxd_r}; end else begin rx_ip_target \u0026lt;= rx_ip_target; end // Capture source ip address if(rx_cnt \u0026gt;= 8\u0026#39;d14 \u0026amp;\u0026amp; rx_cnt \u0026lt; 8\u0026#39;d18) begin rx_ip_source \u0026lt;= {rx_ip_source[23:0],gmii_rxd_r}; end else begin rx_ip_source \u0026lt;= rx_ip_source; end // Capture op type if(rx_cnt \u0026gt;= 8\u0026#39;d6 \u0026amp;\u0026amp; rx_cnt \u0026lt; 8\u0026#39;d8) begin rx_op_type \u0026lt;= {rx_op_type[7:0],gmii_rxd_r}; end else begin rx_op_type \u0026lt;= rx_op_type; end // Check if((rx_cnt == 8\u0026#39;d28 \u0026amp;\u0026amp; rx_ip_target != FPGA_IP) || ((rx_cnt == 8\u0026#39;d8 \u0026amp;\u0026amp; rx_op_type != 16\u0026#39;d1) \u0026amp;\u0026amp; (rx_cnt == 8\u0026#39;d8 \u0026amp;\u0026amp; rx_op_type != 16\u0026#39;d2)) || (rx_cnt == 8\u0026#39;d0 \u0026amp;\u0026amp; rx_eth_type != ETH_TYPE)) begin err_en \u0026lt;= 1\u0026#39;b1; end else begin err_en \u0026lt;= 1\u0026#39;b0; end end else begin end // Finish ETH_HEAD state if(rx_cnt == 8\u0026#39;d45) begin rx_cnt \u0026lt;= 8\u0026#39;b0; arp_rx_type_int \u0026lt;= rx_op_type; src_ip_int \u0026lt;= rx_ip_source; end else begin rx_cnt \u0026lt;= rx_cnt + 1\u0026#39;b1; end if(rx_cnt == 8\u0026#39;d44) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end end FCS : begin if(gmii_rx_dv_r) begin // Finish FCS state if(rx_cnt == 8\u0026#39;d3) begin arp_rx_done_int \u0026lt;= 1\u0026#39;b1; end else begin arp_rx_done_int \u0026lt;= 1\u0026#39;b0; end end else begin arp_rx_done_int \u0026lt;= 1\u0026#39;b0; end if(rx_cnt == 8\u0026#39;d3) begin rx_cnt \u0026lt;= 8\u0026#39;b0; end else begin rx_cnt \u0026lt;= rx_cnt + 1\u0026#39;b1; end if(rx_cnt == 8\u0026#39;d2) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end end default : begin state_done \u0026lt;= 1\u0026#39;b0; end endcase end end assign arp_rx_done = arp_rx_done_int; assign arp_rx_type = arp_rx_type_int; assign src_mac = src_mac_int; assign src_ip = src_ip_int; endmodule 6. ARP 发送构造模块 arp_tx.v # 6.1 描述 # arp_tx 模块负责根据输入信息构造 ARP Request 或 ARP Reply 报文，并通过 MAC 接口发送出去。\n6.2 接口示例 # 信号名 方向 位宽 时钟域 说明 clk In 1 GMII TX 时钟 与 gmii_tx_clk 相同 rst_n In 1 — 低电平复位 arp_tx_en In 1 clk ARP 发送使能，上升沿有效，触发一次完整 ARP 帧发送 arp_tx_type In 1 clk 发送类型：0=ARP Request，1=ARP Reply target_mac In 48 clk 目标 MAC 地址：Reply 时为应答对象；Request 可填 0 或广播 target_ip In 32 clk 目标 IP 地址，ARP Request 的查询对象 IP crc_data In 32 clk CRC32 当前寄存器值（来自 crc32_d8 模块） crc_next In 8 clk CRC32 下一拍高 8bit，用于最后一个 FCS 字节 tx_done Out 1 clk 一帧 ARP 发送完成脉冲 gmii_tx_en Out 1 clk GMII 发送数据有效 gmii_txd Out 8 clk GMII 发送数据总线：前导码+SFD+MAC 头+ARP+Padding+FCS crc_en Out 1 clk CRC 使能，高电平表示当前 gmii_txd 参与 CRC 计算 crc_clr Out 1 clk CRC 清零脉冲，通常在一帧发送结束后一拍拉高 6.3 构造报文伪代码（逻辑思路） # module arp_tx # ( //parameter define // FPGA MAC address 00-11-22-33-44-55 parameter FPGA_MAC = {48\u0026#39;h00_11_22_33_44_55}, // FPGA IP address 192.168.1.10 parameter FPGA_IP = {8\u0026#39;d192,8\u0026#39;d168,8\u0026#39;d1,8\u0026#39;d10}, // target MAC address ff_ff_ff_ff_ff_ff parameter TARGET_MAC = {48\u0026#39;hff_ff_ff_ff_ff_ff}, // target IP address 192.168.1.102 parameter TARGET_IP = {8\u0026#39;d192,8\u0026#39;d168,8\u0026#39;d1,8\u0026#39;d102} ) ( input clk , //clock signal input rst_n , //reset signal, active low input arp_tx_en , //ARP send enable input arp_tx_type, //ARP type 0:request 1:reply input [47:0] target_mac , input [31:0] target_ip , input [31:0] crc_data , input [7:0] crc_next , output tx_done , output gmii_tx_en , output [7:0] gmii_txd , output crc_en , output crc_clr ); //interface reg define reg arp_tx_en_r; //ARP send enable reg arp_tx_en_rr; reg arp_tx_type_r; //ARP type 0:request 1:reply reg [47:0] target_mac_r; reg [31:0] target_ip_r ; always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin arp_tx_en_r \u0026lt;= 1\u0026#39;b0; arp_tx_en_rr \u0026lt;= 1\u0026#39;b0; arp_tx_type_r \u0026lt;= 1\u0026#39;b0; target_mac_r \u0026lt;= 48\u0026#39;d0; target_ip_r \u0026lt;= 32\u0026#39;d0; end else begin arp_tx_en_r \u0026lt;= arp_tx_en; arp_tx_en_rr \u0026lt;= arp_tx_en_r; arp_tx_type_r \u0026lt;= arp_tx_type; target_mac_r \u0026lt;= target_mac; target_ip_r \u0026lt;= target_ip ; end end reg tx_done_int ; reg gmii_tx_en_int ; reg [7:0] gmii_txd_int ; reg crc_en_int ; reg crc_clr_int ; localparam IDLE = 6\u0026#39;b00_0001; //idle state localparam PREAMBLE = 6\u0026#39;b00_0010; //preamble 7 bytes 8\u0026#39;h55 localparam SFD = 6\u0026#39;b00_0100; //sfd 1 byte 8\u0026#39;hd5 localparam ETH_HEAD = 6\u0026#39;b00_1000; //eth head 14 bytes target mac(6) + source mac(6) + eth type(2) localparam ARP_DATA = 6\u0026#39;b01_0000; //arp data 28 bytes hardware type(2) + protocol type(2) + //hardware size(1) + protocol size(1) + opcode(2) + //source mac(6) + source ip(4) + dest mac(6) + dest ip(4) localparam FCS = 6\u0026#39;b10_0000; //fcs 4 bytes localparam ETH_TYPE = 16\u0026#39;h0806 ; //ethernet type ARP localparam HD_TYPE = 16\u0026#39;h0001 ; //hardware type ethernet localparam PROTOCOL_TYPE= 16\u0026#39;h0800 ; //protocol type IP //minimum ethernet data is 46 bytes, fill with padding if not enough localparam MIN_DATA_NUM = 16\u0026#39;d46 ; reg [5:0] cur_state; reg [5:0] next_state; reg state_done; reg [7:0] tx_cnt;//byte counter,arp have 28 bytes data,so max cnt is 27 is enough reg [7:0] preamble [7:0];//preamble data + sfd reg [7:0] eth_head [13:0];//eth head data reg [7:0] arp_data [27:0];//arp data always @ (posedge clk or negedge rst_n) begin if(!rst_n) begin cur_state \u0026lt;= IDLE; end else begin cur_state \u0026lt;= next_state; end end always @ (*) begin next_state = IDLE; case(cur_state) IDLE: begin if(state_done) next_state = PREAMBLE; else next_state = IDLE; end PREAMBLE: begin if(state_done) next_state = SFD; else next_state = PREAMBLE; end SFD: begin next_state = ETH_HEAD; end ETH_HEAD: begin if(state_done) next_state = ARP_DATA; else next_state = ETH_HEAD; end ARP_DATA: begin if(state_done) next_state = FCS; else next_state = ARP_DATA; end FCS: begin if(state_done) next_state = IDLE; else next_state = FCS; end default: begin next_state = IDLE; end endcase end always @ (posedge clk or negedge rst_n) begin if (!rst_n) begin state_done \u0026lt;= 1\u0026#39;b0; tx_cnt \u0026lt;= 8\u0026#39;d0; tx_done_int \u0026lt;= 1\u0026#39;b0; gmii_tx_en_int \u0026lt;= 1\u0026#39;b0; gmii_txd_int \u0026lt;= 8\u0026#39;d0; crc_en_int \u0026lt;= 1\u0026#39;b0; preamble[0] \u0026lt;= 8\u0026#39;h55; preamble[1] \u0026lt;= 8\u0026#39;h55; preamble[2] \u0026lt;= 8\u0026#39;h55; preamble[3] \u0026lt;= 8\u0026#39;h55; preamble[4] \u0026lt;= 8\u0026#39;h55; preamble[5] \u0026lt;= 8\u0026#39;h55; preamble[6] \u0026lt;= 8\u0026#39;h55; preamble[7] \u0026lt;= 8\u0026#39;hd5; eth_head[0] \u0026lt;= TARGET_MAC[47:40]; eth_head[1] \u0026lt;= TARGET_MAC[39:32]; eth_head[2] \u0026lt;= TARGET_MAC[31:24]; eth_head[3] \u0026lt;= TARGET_MAC[23:16]; eth_head[4] \u0026lt;= TARGET_MAC[15:8]; eth_head[5] \u0026lt;= TARGET_MAC[7:0]; eth_head[6] \u0026lt;= FPGA_MAC[47:40]; eth_head[7] \u0026lt;= FPGA_MAC[39:32]; eth_head[8] \u0026lt;= FPGA_MAC[31:24]; eth_head[9] \u0026lt;= FPGA_MAC[23:16]; eth_head[10] \u0026lt;= FPGA_MAC[15:8]; eth_head[11] \u0026lt;= FPGA_MAC[7:0]; eth_head[12] \u0026lt;= ETH_TYPE[15:8]; eth_head[13] \u0026lt;= ETH_TYPE[7:0]; arp_data[0] \u0026lt;= HD_TYPE[15:8]; arp_data[1] \u0026lt;= HD_TYPE[7:0]; arp_data[2] \u0026lt;= PROTOCOL_TYPE[15:8]; arp_data[3] \u0026lt;= PROTOCOL_TYPE[7:0]; arp_data[4] \u0026lt;= 8\u0026#39;d6; arp_data[5] \u0026lt;= 8\u0026#39;d4; arp_data[6] \u0026lt;= 8\u0026#39;d0; // 01 for request, 02 for reply arp_data[7] \u0026lt;= 8\u0026#39;d1; arp_data[8] \u0026lt;= FPGA_MAC[47:40]; arp_data[9] \u0026lt;= FPGA_MAC[39:32]; arp_data[10] \u0026lt;= FPGA_MAC[31:24]; arp_data[11] \u0026lt;= FPGA_MAC[23:16]; arp_data[12] \u0026lt;= FPGA_MAC[15:8]; arp_data[13] \u0026lt;= FPGA_MAC[7:0]; arp_data[14] \u0026lt;= FPGA_IP[31:24]; arp_data[15] \u0026lt;= FPGA_IP[23:16]; arp_data[16] \u0026lt;= FPGA_IP[15:8]; arp_data[17] \u0026lt;= FPGA_IP[7:0]; arp_data[18] \u0026lt;= TARGET_MAC[47:40]; arp_data[19] \u0026lt;= TARGET_MAC[39:32]; arp_data[20] \u0026lt;= TARGET_MAC[31:24]; arp_data[21] \u0026lt;= TARGET_MAC[23:16]; arp_data[22] \u0026lt;= TARGET_MAC[15:8]; arp_data[23] \u0026lt;= TARGET_MAC[7:0]; arp_data[24] \u0026lt;= TARGET_IP[31:24]; arp_data[25] \u0026lt;= TARGET_IP[23:16]; arp_data[26] \u0026lt;= TARGET_IP[15:8]; arp_data[27] \u0026lt;= TARGET_IP[7:0]; end else begin case(cur_state) IDLE: begin tx_done_int \u0026lt;= 1\u0026#39;b0; gmii_tx_en_int \u0026lt;= 1\u0026#39;b0; gmii_txd_int \u0026lt;= 8\u0026#39;d0; crc_en_int \u0026lt;= 1\u0026#39;b0; if(!arp_tx_en_rr \u0026amp;\u0026amp; arp_tx_en_r) //detect rising edge of arp_tx_en state_done \u0026lt;= 1\u0026#39;b1; else state_done \u0026lt;= 1\u0026#39;b0; tx_cnt \u0026lt;= 8\u0026#39;d0; if((target_mac_r != 48\u0026#39;d0) || (target_ip_r != 32\u0026#39;d0)) begin eth_head[0] \u0026lt;= target_mac_r[47:40]; eth_head[1] \u0026lt;= target_mac_r[39:32]; eth_head[2] \u0026lt;= target_mac_r[31:24]; eth_head[3] \u0026lt;= target_mac_r[23:16]; eth_head[4] \u0026lt;= target_mac_r[15:8]; eth_head[5] \u0026lt;= target_mac_r[7:0]; arp_data[18] \u0026lt;= target_mac_r[47:40]; arp_data[19] \u0026lt;= target_mac_r[39:32]; arp_data[20] \u0026lt;= target_mac_r[31:24]; arp_data[21] \u0026lt;= target_mac_r[23:16]; arp_data[22] \u0026lt;= target_mac_r[15:8]; arp_data[23] \u0026lt;= target_mac_r[7:0]; arp_data[24] \u0026lt;= target_ip_r[31:24]; arp_data[25] \u0026lt;= target_ip_r[23:16]; arp_data[26] \u0026lt;= target_ip_r[15:8]; arp_data[27] \u0026lt;= target_ip_r[7:0]; end else begin end if(arp_tx_type_r == 1\u0026#39;b0) begin arp_data[6] \u0026lt;= 8\u0026#39;d0; arp_data[7] \u0026lt;= 8\u0026#39;d1; end else begin arp_data[6] \u0026lt;= 8\u0026#39;d0; arp_data[7] \u0026lt;= 8\u0026#39;d2; end end PREAMBLE : begin if(tx_cnt == 8\u0026#39;d6) begin tx_cnt \u0026lt;= 8\u0026#39;d0; end else begin tx_cnt \u0026lt;= tx_cnt + 8\u0026#39;d1; end if(tx_cnt == 8\u0026#39;d5) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end gmii_tx_en_int \u0026lt;= 1\u0026#39;b1; gmii_txd_int \u0026lt;= preamble[tx_cnt]; end SFD : begin gmii_tx_en_int \u0026lt;= 1\u0026#39;b1; gmii_txd_int \u0026lt;= preamble[7]; tx_cnt \u0026lt;= 8\u0026#39;d0; end ETH_HEAD : begin if(tx_cnt == 8\u0026#39;d13) begin tx_cnt \u0026lt;= 8\u0026#39;d0; end else begin tx_cnt \u0026lt;= tx_cnt + 8\u0026#39;d1; end if(tx_cnt == 8\u0026#39;d12) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end gmii_tx_en_int \u0026lt;= 1\u0026#39;b1; gmii_txd_int \u0026lt;= eth_head[tx_cnt]; crc_en_int \u0026lt;= 1\u0026#39;b1; end ARP_DATA : begin if(tx_cnt == 8\u0026#39;d45) begin tx_cnt \u0026lt;= 8\u0026#39;d0; end else begin tx_cnt \u0026lt;= tx_cnt + 8\u0026#39;d1; end if(tx_cnt == 8\u0026#39;d44) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end gmii_tx_en_int \u0026lt;= 1\u0026#39;b1; if(tx_cnt \u0026lt; 8\u0026#39;d28) gmii_txd_int \u0026lt;= arp_data[tx_cnt]; else gmii_txd_int \u0026lt;= 8\u0026#39;d0; //padding to meet minimum ethernet data length end FCS : begin crc_en_int \u0026lt;= 1\u0026#39;b0; if(tx_cnt == 8\u0026#39;d3) begin tx_cnt \u0026lt;= 8\u0026#39;d0; tx_done_int \u0026lt;= 1\u0026#39;b1; end else begin tx_cnt \u0026lt;= tx_cnt + 8\u0026#39;d1; tx_done_int \u0026lt;= 1\u0026#39;b0; end if(tx_cnt == 8\u0026#39;d2) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end gmii_tx_en_int \u0026lt;= 1\u0026#39;b1; case(tx_cnt) 8\u0026#39;d0 : gmii_txd_int \u0026lt;= {~crc_next[0],~crc_next[1],~crc_next[2],~crc_next[3], ~crc_next[4],~crc_next[5],~crc_next[6],~crc_next[7]}; 8\u0026#39;d1 : gmii_txd_int \u0026lt;= {~crc_data[16],~crc_data[17],~crc_data[18],~crc_data[19], ~crc_data[20],~crc_data[21],~crc_data[22],~crc_data[23]}; 8\u0026#39;d2 : gmii_txd_int \u0026lt;= {~crc_data[8],~crc_data[9],~crc_data[10],~crc_data[11], ~crc_data[12],~crc_data[13],~crc_data[14],~crc_data[15]}; 8\u0026#39;d3 : gmii_txd_int \u0026lt;= {~crc_data[0],~crc_data[1],~crc_data[2],~crc_data[3], ~crc_data[4],~crc_data[5],~crc_data[6],~crc_data[7]}; default : begin end endcase end default : begin end endcase end end always @ (posedge clk or negedge rst_n) begin if (!rst_n) begin crc_clr_int \u0026lt;= 1\u0026#39;b0; end else begin crc_clr_int \u0026lt;= tx_done_int; end end assign tx_done = tx_done_int ; assign gmii_tx_en = gmii_tx_en_int; assign gmii_txd = gmii_txd_int ; assign crc_en = crc_en_int ; assign crc_clr = crc_clr_int ; endmodule 7. 仿真与调试建议 # 功能仿真：\n构造 ARP Request 输入帧，检查 arp_rx 是否正确解析字段 检查 arp_tx 生成的 Request/Reply 帧格式是否符合预期 仿真 ARP 缓存命中/未命中场景 硬件调试：\n用 Wireshark 抓包 ARP 报文，核对帧内容与 FPGA 生成的一致性 观察广播 ARP 请求是否遍历交换机端口 检查对端设备是否正确回应 ARP 示例抓包图占位：\n8. 参考资料 # RFC 826 — An Ethernet Address Resolution Protocol 各操作系统 ARP 命令文档（如 arp -a、ip neigh） 常用网络教材相关章节（ARP/以太网/IPv4） ","date":"6 November 2025","externalUrl":null,"permalink":"/docs/arp/","section":"Docs","summary":"\u003ch1 class=\"relative group\"\u003eARP 协议介绍\n    \u003cdiv id=\"arp-协议介绍\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#arp-%e5%8d%8f%e8%ae%ae%e4%bb%8b%e7%bb%8d\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e\u003cbr\u003e\n本文是一个用于介绍 \u003cstrong\u003eARP（Address Resolution Protocol，地址解析协议）\u003c/strong\u003e 的 Verilog 模块示例框架文档。\u003cbr\u003e\n你可以在此基础上增删内容、替换图片和表格数据，作为工程文档或学习笔记使用。\u003c/p\u003e","title":"ARP 协议介绍","type":"docs"},{"content":"","date":"6 November 2025","externalUrl":null,"permalink":"/docs/","section":"Docs","summary":"","title":"Docs","type":"docs"},{"content":"","date":"6 November 2025","externalUrl":null,"permalink":"/tags/fpga/","section":"Tags","summary":"","title":"FPGA","type":"tags"},{"content":"","date":"6 November 2025","externalUrl":null,"permalink":"/tags/ipv4/","section":"Tags","summary":"","title":"IPv4","type":"tags"},{"content":"","date":"6 November 2025","externalUrl":null,"permalink":"/tags/verilog/","section":"Tags","summary":"","title":"Verilog","type":"tags"},{"content":"","date":"6 November 2025","externalUrl":null,"permalink":"/tags/%E4%BB%A5%E5%A4%AA%E7%BD%91/","section":"Tags","summary":"","title":"以太网","type":"tags"},{"content":" Bilinear interpolation 是一种在嵌入式和 FPGA 上都很实用的图像缩放方法。\n每个输出像素由源图像中最近的四个像素加权平均得到，比最近邻平滑得多，又比高阶滤波器便宜很多。\n本篇主要讲数学和坐标映射；下一篇会对应 Verilog 架构和实现。\n1. 坐标映射：输出像素来自源图像的哪里？ # 设原图尺寸为 w × h，目标图尺寸为 new_w × new_h。则缩放因子为：\n水平方向：scale_x = w / new_w 垂直方向：scale_y = h / new_h 对目标图中整数坐标 (i, j)（0-based），映射到源图中的连续坐标 (src_x, src_y)：\nsrc_x = (i + 0.5) * scale_x - 0.5 src_y = (j + 0.5) * scale_y - 0.5 +0.5 与 -0.5 的作用是让像素中心对齐：当缩放比例为 1× 时，输出图像不会整体平移。([1 Bit FPGA][1])\n接着将连续坐标拆分为整数部分与小数部分：\nx_int = floor(src_x) y_int = floor(src_y) a_x = src_x - x_int // 0..1 a_y = src_y - y_int // 0..1 四个相邻的整数栅格点分别是：\nQ11 = (x_int, y_int) Q21 = (x_int + 1, y_int) Q12 = (x_int, y_int + 1) Q22 = (x_int + 1, y_int + 1) 2. 两种等价的插值公式 # 设灰度值或某个颜色通道的值记为 f(·)。\n2.1 先横向后纵向的两步线性插值（LERP） # 水平方向插值： f(x, y_int) = (1 - a_x) * f(Q11) + a_x * f(Q21) f(x, y_int + 1) = (1 - a_x) * f(Q12) + a_x * f(Q22) 垂直方向插值： I(x, y) = (1 - a_y) * f(x, y_int) + a_y * f(x, y_int + 1) 2.2 一步完成的加权和公式 # 把上下两步合并，可写成四个点的加权和：([1 Bit FPGA][1])\nI(x, y) = (1 - a_x) * (1 - a_y) * f(Q11) + a_x * (1 - a_y) * f(Q21) + (1 - a_x) * a_y * f(Q12) + a_x * a_y * f(Q22) 在 RGB 图像中，对 R/G/B 三个通道分别独立应用同样的插值权重即可。\n3. 示例：4×4 放大到 8×8（单通道） # 原始 4×4 像素值示例：\n10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 目标是放大为 8 × 8，因此缩放因子为：\nscale_x = scale_y = 4 / 8 = 0.5 考虑目标图上像素 (i, j) = (1, 1)：\n映射回源图坐标： src_x = (1 + 0.5) * 0.5 - 0.5 = 0.25 src_y = (1 + 0.5) * 0.5 - 0.5 = 0.25 x_int = 0, y_int = 0 a_x = 0.25 a_y = 0.25 查找四个邻点及其值： Q11 = (0, 0) -\u0026gt; 10 Q21 = (1, 0) -\u0026gt; 20 Q12 = (0, 1) -\u0026gt; 50 Q22 = (1, 1) -\u0026gt; 60 两步插值计算： f(x, y_int) = 0.75 * 10 + 0.25 * 20 = 12.5 f(x, y_int + 1) = 0.75 * 50 + 0.25 * 60 = 52.5 I(x, y) = 0.75 * 12.5 + 0.25 * 52.5 = 22.5 实际图像中，会再根据约定进行取整，例如向最近整数四舍五入，得到 22 或 23。([1 Bit FPGA][1])\n4. 对矩阵进行双线性插值的 Python 示例 # 下面是一个使用 NumPy 实现双线性插值的示例函数，用于将任意大小的 2D 数组缩放到新尺寸。代码思路与文中示例一致，但变量命名和注释略有调整，便于直接复用在工程中。\nimport numpy as np def bilinear_interpolation(input_matrix: np.ndarray, new_shape): \u0026#34;\u0026#34;\u0026#34; Resize a 2D matrix using bilinear interpolation. input_matrix: 2D numpy array, shape (src_h, src_w) new_shape: tuple (dst_h, dst_w) \u0026#34;\u0026#34;\u0026#34; src_h, src_w = input_matrix.shape dst_h, dst_w = new_shape output = np.zeros((dst_h, dst_w), dtype=float) # 注意：这里使用 (N-1)/(M-1) 的写法，可以保证首尾像素对齐 scale_x = (src_w - 1) / (dst_w - 1) if dst_w \u0026gt; 1 else 0.0 scale_y = (src_h - 1) / (dst_h - 1) if dst_h \u0026gt; 1 else 0.0 for i in range(dst_h): for j in range(dst_w): # 映射到源图连续坐标（以像素中心为基准） src_x = (j + 0.5) * scale_x - 0.5 src_y = (i + 0.5) * scale_y - 0.5 x0 = int(np.floor(src_x)) y0 = int(np.floor(src_y)) x1 = min(x0 + 1, src_w - 1) y1 = min(y0 + 1, src_h - 1) wx = src_x - x0 wy = src_y - y0 # 四个点加权求和 v00 = input_matrix[y0, x0] v10 = input_matrix[y0, x1] v01 = input_matrix[y1, x0] v11 = input_matrix[y1, x1] output[i, j] = ( v00 * (1 - wx) * (1 - wy) + v10 * wx * (1 - wy) + v01 * (1 - wx) * wy + v11 * wx * wy ) return output 你可以用文中的 4×4 示例矩阵验证：\ninput_matrix = np.array([ [10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160], ]) output_matrix = bilinear_interpolation(input_matrix, (8, 8)) print(output_matrix) ","date":"31 August 2025","externalUrl":null,"permalink":"/docs/hello-world/","section":"Docs","summary":"\u003chr\u003e\n\u003cp\u003eBilinear interpolation 是一种在嵌入式和 FPGA 上都很实用的图像缩放方法。\u003cbr\u003e\n每个输出像素由源图像中最近的四个像素加权平均得到，比最近邻平滑得多，又比高阶滤波器便宜很多。\u003c/p\u003e","title":"Bilinear Image Scaling in Verilog: Bilinear Interpolation Explanation","type":"docs"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/bilinear-verilog/","section":"Tags","summary":"","title":"Bilinear Verilog","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/bilinear-image-scaling/","section":"Tags","summary":"","title":"Bilinear-Image-Scaling","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/mdio-verilog/","section":"Tags","summary":"","title":"Mdio Verilog","type":"tags"},{"content":" MDIO 接口介绍 # 说明：\n本文是一个用于介绍 MDIO（Management Data Input/Output）接口 的YT8531的verilog模块示例。\n你可以在此基础上增删内容、替换图片和表格数据，作为项目文档或学习笔记使用。\n1. 概述（Overview） # MDIO（Management Data Input/Output） 是以太网中用于访问 PHY（物理层芯片）内部寄存器的管理总线接口。 通常由 MAC 或专用管理控制器作为主机，通过 MDIO 对多个 PHY 进行配置和状态读取。\n标准来源：IEEE 802.3（Clause 22 / Clause 45） 常见应用场景： 千兆/百兆以太网 PHY 配置 链路状态监控（Link up/down、速度、双工等） 调试与寄存器读写 2. MDIO 信号与基本连接 # 2.1 主从拓扑结构 # 典型连接结构如图所示：\n+-----------+ +---------+ | MAC/FPGA | | PHY #0 | |-----------| MDC |---------| | MDIO ----+----------\u0026gt;| MDIO | | MDC -------------+--\u0026gt;| MDC | +-----------+ | +---------+ | | +---------+ +--\u0026gt;| PHY #1 | |---------| | MDIO | | MDC | +---------+ 说明：\n主设备：MAC / FPGA / SoC 内部的 MDIO 控制器 从设备：一个或多个 PHY 芯片 所有 PHY 共用同一条 MDIO/MDC 线，通过不同 PHY 地址区分 2.2 信号定义 # 信号名 方向（相对主机） 描述 MDC 输出 管理总线时钟，典型 \u0026lt; 2.5 MHz MDIO 双向 管理数据线，开漏/三态共享总线 GND - 参考地 VCC - 供电（与 PHY 规格相关） 3. 帧格式（Clause 22 为例） # 3.1 MDIO 帧结构 # Clause 22 标准下，一帧 MDIO 报文结构如下（写/读命令略有差异）：\nPreamble ST OP PHYAD REGAD TA Data (16 bits) 32\u0026rsquo;hffff_ffff 01 10/01 5bit 5bit 2bit 16bit 典型帧结构如图所示： 4. 整体框架 mdio_top.v # 4.1 描述 # 根据芯片手册，MDIO 接口的 MDC 时钟一般不超过 12.5 MHz。本设计中由系统时钟分频得到约 10 MHz 的时钟，作为 MDIO 读写时序的驱动时钟，保证满足各类 PHY 芯片对 MDC 的时序要求。\nmdio_top 模块内部采用有限状态机（FSM）控制 MDIO 总线时序，完整的一次访问大致分为 8 个状态：空闲、前导码发送、起始帧、操作码、地址段、周转段以及数据读写段。各状态功能如下表所示：\nstate 描述 IDLE 空闲状态，等待 start_sig 触发新的 MDIO 访问 PRE 发送一串连续的前导码（通常为 32 个 “1”），唤醒 MDIO 总线 ST 发送起始帧（Start），标识一次 MDIO 访问的开始 OP 发送操作码字段（OP），指示本次为读操作还是写操作 ADDR 依次发送 PHY 地址和寄存器地址字段 TA 周转（Turn Around）状态，控制 MDIO 方向的切换 W_DATA 写数据状态，按位在 MDIO 线上发送 16 位写入数据 R_DATA 读数据状态，从 MDIO 总线上按位采集 16 位读出数据 4.1 mdio_top接口 # 信号名 方向 描述 clk 输入 系统时钟 rst_n 输入 复位信号 rst_n_key 输入 硬复位 led 输出 速率指示灯 mdio 双向 数据线 mdc 输出 时钟线 4.1 实现 # mdio_top模块是顶层模块，由mdio_wr模块、mdio_ctrl模块、以及pll锁相环模块组成。\nmdio_wr模块是核心模块，主要作用是与PHY芯片通信，mdio_ctrl模块用来控制mdio_wr模块，给它不同的地址与命令\nmodule mdio_top( input clk, input rst_n, input rst_n_key, output [1:0] led, // MDIO Interface inout mdio, output mdc ); wire mdio_ack; wire [15:0] mdio_rd_data; wire mdio_wr_done; wire start_sig; wire [1:0] opt; wire [4:0] phy_addr; wire [4:0] reg_addr; wire [1:0] ta; wire [15:0] wr_data; wire clk_out1; clk_wiz_0 instance_name ( // Clock out ports .clk_out1(clk_out1), // output clk_out1 // Status and control signals .resetn(rst_n), // input resetn // Clock in ports .clk_in1(clk)); // input clk_in1 mdio_ctrl u_mdio_ctrl ( .clk (clk_out1), .rst_n (rst_n), .rst_n_key (rst_n_key), .mdio_ack (mdio_ack), // = mdio_rd_ask .mdio_rd_data (mdio_rd_data), .mdio_wr_done (mdio_wr_done), .led (led), .start_sig (start_sig), .opt (opt), .phy_addr (phy_addr), .reg_addr (reg_addr), .ta (ta), .wr_data (wr_data) ); mdio_wr u_mdio_wr ( .clk (clk_out1), .rst_n (rst_n), // Inputs from ctrl .start_sig (start_sig), .opt (opt), .phy_addr (phy_addr), .reg_addr (reg_addr), .ta (ta), .wr_data (wr_data), // Outputs back to ctrl .mdio_rd_data (mdio_rd_data), .mdio_wr_done (mdio_wr_done), .mdio_rd_ask (mdio_ack), // MDIO PHY interface .mdio (mdio), .mdc (mdc) ); endmodule 4.2 MDIO的读写模块mdio_wr.v # 4.2.1 描述 # mdio核心模块，与PHY直接通信，相当于一个配置PHY芯片通信模块。\n4.2.2 接口 # 信号名 方向 描述 clk 输入 系统时钟 rst_n 输入 复位信号，低有效 start_sig 输入 访问开始信号 opt[1:0] 输入 操作类型选择（如读/写） phy_addr[4:0] 输入 PHY 设备地址 reg_addr[4:0] 输入 寄存器地址 ta[1:0] 输入 TA 周转位配置 wr_data[15:0] 输入 待写入 MDIO 的 16 位数据 mdio_rd_data[15:0] 输出 从 MDIO 读出的 16 位数据 mdio_wr_done 输出 MDIO 访问完成标志 mdio_rd_ask 输出 MDIO 读请求指示信号 mdio 双向 MDIO 数据线 mdc 输出 MDIO 时钟线 4.2.2 实现 # module mdio_wr( input clk, input rst_n, // Inputs input start_sig, input [1:0] opt, input [4:0] phy_addr, input [4:0] reg_addr, input [1:0] ta, input [15:0] wr_data, // Outputs output [15:0] mdio_rd_data, output mdio_wr_done, output mdio_rd_ask, // MDIO Interface inout mdio, output mdc ); localparam IDLE = 8\u0026#39;b0000_0001; localparam PRE = 8\u0026#39;b0000_0010; localparam ST = 8\u0026#39;b0000_0100; localparam OP = 8\u0026#39;b0000_1000; localparam ADDR = 8\u0026#39;b0001_0000; localparam TA = 8\u0026#39;b0010_0000; localparam W_DATA = 8\u0026#39;b0100_0000; localparam R_DATA = 8\u0026#39;b1000_0000; reg [7:0] cur_state ; reg [7:0] next_state; reg start_sig_r; reg [1:0] opt_r; reg [4:0] phy_addr_r; reg [4:0] reg_addr_r; reg [1:0] ta_r; reg [15:0] wr_data_r; reg mdio_rd_ask_int; reg [15:0] mdio_rd_data_int; reg mdio_wr_done_int; // mdc clk reg [5:0] clk_cnt; reg mdc_int; reg clk_12_5m; always @ (posedge clk or negedge rst_n) begin if (!rst_n) begin clk_cnt \u0026lt;= 6\u0026#39;b0; clk_12_5m \u0026lt;= 1\u0026#39;b0; end else if (clk_cnt == 6\u0026#39;d1) begin clk_12_5m \u0026lt;= !clk_12_5m; clk_cnt \u0026lt;= 6\u0026#39;b0; end else begin clk_12_5m \u0026lt;= clk_12_5m; clk_cnt \u0026lt;= clk_cnt + 1\u0026#39;b1; end end // mdio timing cnt reg [6:0] mdio_bit_cnt; reg state_done; // mdio inout reg mdio_out; reg mdio_en; wire mdio_in; assign mdio = mdio_en ? mdio_out : 1\u0026#39;bz; assign mdio_in = mdio; always @ (posedge clk_12_5m or negedge rst_n) begin if (!rst_n) begin start_sig_r \u0026lt;= 1\u0026#39;b0; opt_r \u0026lt;= 2\u0026#39;b0; phy_addr_r \u0026lt;= 5\u0026#39;b0; reg_addr_r \u0026lt;= 5\u0026#39;b0; ta_r \u0026lt;= 2\u0026#39;b0; wr_data_r \u0026lt;= 16\u0026#39;b0; end else begin start_sig_r \u0026lt;= start_sig; opt_r \u0026lt;= opt; phy_addr_r \u0026lt;= phy_addr; reg_addr_r \u0026lt;= reg_addr; ta_r \u0026lt;= ta; wr_data_r \u0026lt;= wr_data; end end always @ (posedge clk_12_5m or negedge rst_n) begin if (!rst_n) cur_state \u0026lt;= IDLE; else cur_state \u0026lt;= next_state; end always @ (*) begin next_state = IDLE; case(cur_state) IDLE: if(start_sig_r) next_state = PRE; else next_state = IDLE; PRE: if(state_done) begin next_state = ST; end else begin next_state = PRE; end ST: if(state_done) begin next_state = OP; end else begin next_state = ST; end OP: if(state_done) begin next_state = ADDR; end else begin next_state = OP; end ADDR: if(state_done) begin next_state = TA; end else begin next_state = ADDR; end TA: if(state_done \u0026amp;\u0026amp; (opt_r == 2\u0026#39;b01)) begin next_state = W_DATA; end else if(state_done \u0026amp;\u0026amp; (opt_r == 2\u0026#39;b10)) begin next_state = R_DATA; end else begin next_state = TA; end W_DATA: if(state_done) begin next_state = IDLE; end else begin next_state = W_DATA; end R_DATA: if(state_done) begin next_state = IDLE; end else begin next_state = R_DATA; end default: begin next_state = IDLE; end endcase end always @ (posedge clk_12_5m or negedge rst_n) begin if (!rst_n) begin mdc_int \u0026lt;= 1\u0026#39;b1; mdio_en \u0026lt;= 1\u0026#39;b0; mdio_out \u0026lt;= 1\u0026#39;b1; mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; mdio_rd_ask_int \u0026lt;= 1\u0026#39;b1; mdio_rd_data_int \u0026lt;= 16\u0026#39;b0; mdio_wr_done_int \u0026lt;= 1\u0026#39;b0; end else begin case(cur_state) IDLE: begin mdc_int \u0026lt;= 1\u0026#39;b1; mdio_en \u0026lt;= 1\u0026#39;b0; mdio_out \u0026lt;= 1\u0026#39;b1; mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; mdio_rd_ask_int \u0026lt;= 1\u0026#39;b1; mdio_wr_done_int \u0026lt;= 1\u0026#39;b0; end PRE: begin mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d63) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt \u0026lt; 7\u0026#39;d63) begin mdio_out \u0026lt;= 1\u0026#39;b1; end else begin mdio_out \u0026lt;= 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d62) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end end ST: begin mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d3) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d2) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= 1\u0026#39;b0; // Start bit 7\u0026#39;d2: mdio_out \u0026lt;= 1\u0026#39;b1; // ST bit default: ; endcase end OP: begin mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d3) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;d0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d2) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end if(opt_r == 2\u0026#39;b01) begin // Write operation case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= opt_r[1]; // 1 bit 7\u0026#39;d2: mdio_out \u0026lt;= opt_r[0]; // 2 bit default: ; endcase end else if(opt_r == 2\u0026#39;b10) begin // Read operation case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= opt_r[1]; // 1 bit 7\u0026#39;d2: mdio_out \u0026lt;= opt_r[0]; // 2 bit default: ; endcase end end ADDR: begin // PHY address and Register address mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d19) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;d0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d18) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= phy_addr_r[4]; // PHY address bit 0 7\u0026#39;d2: mdio_out \u0026lt;= phy_addr_r[3]; // PHY address bit 1 7\u0026#39;d4: mdio_out \u0026lt;= phy_addr_r[2]; // PHY address bit 2 7\u0026#39;d6: mdio_out \u0026lt;= phy_addr_r[1]; // PHY address bit 3 7\u0026#39;d8: mdio_out \u0026lt;= phy_addr_r[0]; // PHY address bit 4 7\u0026#39;d10: mdio_out \u0026lt;= reg_addr_r[4]; // Register address bit 0 7\u0026#39;d12: mdio_out \u0026lt;= reg_addr_r[3]; // Register address bit 1 7\u0026#39;d14: mdio_out \u0026lt;= reg_addr_r[2]; // Register address bit 2 7\u0026#39;d16: mdio_out \u0026lt;= reg_addr_r[1]; // Register address bit 3 7\u0026#39;d18: mdio_out \u0026lt;= reg_addr_r[0]; // Register address bit 4 default: ; endcase end TA: begin // Turnaround mdc_int \u0026lt;= ~mdc_int; if (mdio_bit_cnt == 7\u0026#39;d3) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;d0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d2) begin state_done \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; end if(opt_r == 2\u0026#39;b01) begin // Write operation mdio_en \u0026lt;= 1\u0026#39;b1; case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= 1\u0026#39;b1; // 1 bit 7\u0026#39;d2: mdio_out \u0026lt;= 1\u0026#39;b0; // 2 bit default: ; endcase end else if(opt_r == 2\u0026#39;b10) begin // Read operation mdio_out \u0026lt;= 1\u0026#39;b1; mdio_en \u0026lt;= 1\u0026#39;b0; case(mdio_bit_cnt) 7\u0026#39;d0: ; // 1 bit 7\u0026#39;d2: mdio_rd_ask_int \u0026lt;= mdio_in; // 2 bit default: ; endcase end end W_DATA: begin // Write data to MDIO mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b1; if (mdio_bit_cnt == 7\u0026#39;d32) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d31) begin state_done \u0026lt;= 1\u0026#39;b1; mdio_wr_done_int \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; mdio_wr_done_int \u0026lt;= 1\u0026#39;b0; end case(mdio_bit_cnt) 7\u0026#39;d0: mdio_out \u0026lt;= wr_data_r[15]; // 7\u0026#39;d2: mdio_out \u0026lt;= wr_data_r[14]; // 7\u0026#39;d4: mdio_out \u0026lt;= wr_data_r[13]; // 7\u0026#39;d6: mdio_out \u0026lt;= wr_data_r[12]; // 7\u0026#39;d8: mdio_out \u0026lt;= wr_data_r[11]; // 7\u0026#39;d10: mdio_out \u0026lt;= wr_data_r[10]; // 7\u0026#39;d12: mdio_out \u0026lt;= wr_data_r[9]; // 7\u0026#39;d14: mdio_out \u0026lt;= wr_data_r[8]; // 7\u0026#39;d16: mdio_out \u0026lt;= wr_data_r[7]; // 7\u0026#39;d18: mdio_out \u0026lt;= wr_data_r[6]; // 7\u0026#39;d20: mdio_out \u0026lt;= wr_data_r[5]; // 7\u0026#39;d22: mdio_out \u0026lt;= wr_data_r[4]; // 7\u0026#39;d24: mdio_out \u0026lt;= wr_data_r[3]; // 7\u0026#39;d26: mdio_out \u0026lt;= wr_data_r[2]; // 7\u0026#39;d28: mdio_out \u0026lt;= wr_data_r[1]; // 7\u0026#39;d30: mdio_out \u0026lt;= wr_data_r[0]; // 7\u0026#39;d32: mdio_out \u0026lt;= 1\u0026#39;b1; // default: ; endcase end R_DATA: begin // Read data from MDIO mdc_int \u0026lt;= ~mdc_int; mdio_en \u0026lt;= 1\u0026#39;b0; if (mdio_bit_cnt == 7\u0026#39;d31) begin mdio_bit_cnt \u0026lt;= 7\u0026#39;b0; end else begin mdio_bit_cnt \u0026lt;= mdio_bit_cnt + 1\u0026#39;b1; end if (mdio_bit_cnt == 7\u0026#39;d30) begin state_done \u0026lt;= 1\u0026#39;b1; mdio_wr_done_int \u0026lt;= 1\u0026#39;b1; end else begin state_done \u0026lt;= 1\u0026#39;b0; mdio_wr_done_int \u0026lt;= 1\u0026#39;b0; end case(mdio_bit_cnt) 7\u0026#39;d0: mdio_rd_data_int[15] \u0026lt;= mdio_in; // 7\u0026#39;d2: mdio_rd_data_int[14] \u0026lt;= mdio_in; // 7\u0026#39;d4: mdio_rd_data_int[13] \u0026lt;= mdio_in; // 7\u0026#39;d6: mdio_rd_data_int[12] \u0026lt;= mdio_in; // 7\u0026#39;d8: mdio_rd_data_int[11] \u0026lt;= mdio_in; // 7\u0026#39;d10: mdio_rd_data_int[10] \u0026lt;= mdio_in; // 7\u0026#39;d12: mdio_rd_data_int[9] \u0026lt;= mdio_in; // 7\u0026#39;d14: mdio_rd_data_int[8] \u0026lt;= mdio_in; // 7\u0026#39;d16: mdio_rd_data_int[7] \u0026lt;= mdio_in; // 7\u0026#39;d18: mdio_rd_data_int[6] \u0026lt;= mdio_in; // 7\u0026#39;d20: mdio_rd_data_int[5] \u0026lt;= mdio_in; // 7\u0026#39;d22: mdio_rd_data_int[4] \u0026lt;= mdio_in; // 7\u0026#39;d24: mdio_rd_data_int[3] \u0026lt;= mdio_in; // 7\u0026#39;d26: mdio_rd_data_int[2] \u0026lt;= mdio_in; // 7\u0026#39;d28: mdio_rd_data_int[1] \u0026lt;= mdio_in; // 7\u0026#39;d30: mdio_rd_data_int[0] \u0026lt;= mdio_in; // default: ; endcase end default : ; endcase end end assign mdio_rd_ask = mdio_rd_ask_int; assign mdio_rd_data = mdio_rd_data_int; assign mdc = mdc_int; assign mdio_wr_done = mdio_wr_done_int; endmodule 4.3 MDIO的控制模块mdio_ctrl.v # 4.3.1 描述 # MDIO的控制模块，控制mdio_wr模块。\n4.3.2 接口 # module mdio_ctrl( input clk, input rst_n, input rst_n_key,\ninput mdio_ack,\rinput [15:0] mdio_rd_data,\rinput mdio_wr_done,\routput [1:0] led,\routput start_sig,\routput [1:0] opt,\routput [4:0] phy_addr,\routput [4:0] reg_addr,\routput [1:0] ta,\routput [15:0] wr_data\r);\n4.3.2 实现 # module mdio_ctrl( input clk, input rst_n, input rst_n_key, input mdio_ack, input [15:0] mdio_rd_data, input mdio_wr_done, output [1:0] led, output start_sig, output [1:0] opt, output [4:0] phy_addr, output [4:0] reg_addr, output [1:0] ta, output [15:0] wr_data ); reg mdio_ack_r; reg [15:0] mdio_rd_data_r; reg mdio_wr_done_r; reg mdio_wr_done_rr; reg [1:0] led_int; reg start_sig_int; reg [1:0] opt_int; reg [4:0] phy_addr_int; reg [4:0] reg_addr_int; reg [1:0] ta_int; reg [15:0] wr_data_int; parameter INIT_TIME_CNT = 24\u0026#39;d5_000_000; reg [23:0] init_timer_cnt; reg init_done; reg rst_n_key_r0; reg rst_n_key_r1; reg rst_n_key_r2; reg rst_key_flag; localparam IDLE = 5\u0026#39;b00001; localparam START = 5\u0026#39;b00010; localparam READ = 5\u0026#39;b00100; localparam WRITE = 5\u0026#39;b01000; localparam READ2 = 5\u0026#39;b10000; reg [4:0] cur_state; reg [4:0] next_state; reg [9:0] state_cnt; reg state_done; reg link_error; reg [1:0] speed_status; always @(posedge clk or negedge rst_n) begin if (!rst_n) begin rst_n_key_r0 \u0026lt;= 1\u0026#39;b0; rst_n_key_r1 \u0026lt;= 1\u0026#39;b0; rst_n_key_r2 \u0026lt;= 1\u0026#39;b0; rst_key_flag \u0026lt;= 1\u0026#39;b0; mdio_ack_r \u0026lt;= 1\u0026#39;b0; mdio_rd_data_r \u0026lt;= 16\u0026#39;b0; mdio_wr_done_r \u0026lt;= 1\u0026#39;b0; mdio_wr_done_rr \u0026lt;= 1\u0026#39;b0; end else begin rst_n_key_r0 \u0026lt;= rst_n_key; rst_n_key_r1 \u0026lt;= rst_n_key_r0; rst_n_key_r2 \u0026lt;= rst_n_key_r1; rst_key_flag \u0026lt;= ~rst_n_key_r2 \u0026amp; rst_n_key_r1; mdio_ack_r \u0026lt;= mdio_ack; mdio_rd_data_r \u0026lt;= mdio_rd_data; mdio_wr_done_r \u0026lt;= mdio_wr_done; mdio_wr_done_rr \u0026lt;= mdio_wr_done_r; end end always @(posedge clk or negedge rst_n) begin if (!rst_n) begin init_timer_cnt \u0026lt;= 24\u0026#39;b0; init_done \u0026lt;= 1\u0026#39;b0; end else if (rst_key_flag) begin init_timer_cnt \u0026lt;= 24\u0026#39;b0; init_done \u0026lt;= 1\u0026#39;b0; end else if (init_timer_cnt == INIT_TIME_CNT - 1) begin init_timer_cnt \u0026lt;= 24\u0026#39;b0; init_done \u0026lt;= 1\u0026#39;b1; end else begin init_done \u0026lt;= 1\u0026#39;b0; init_timer_cnt \u0026lt;= init_timer_cnt + 1\u0026#39;b1; end end always @ (posedge clk or negedge rst_n) begin if (!rst_n) begin cur_state \u0026lt;= IDLE; end else begin if(rst_key_flag) cur_state \u0026lt;= IDLE; else cur_state \u0026lt;= next_state; end end always @ (*) begin case(cur_state) IDLE : begin if (init_done) begin next_state = START; end else begin next_state = IDLE; end end START : begin if (state_done) begin next_state = READ; end else begin next_state = START; end end READ : begin if (!mdio_wr_done_rr \u0026amp;\u0026amp; mdio_wr_done_r) begin next_state = WRITE; end else begin next_state = READ; end end WRITE : begin if (!mdio_wr_done_rr \u0026amp;\u0026amp; mdio_wr_done_r) begin next_state = READ2; end else begin next_state = WRITE; end end READ2 : begin next_state = READ2; end default : begin next_state = IDLE; end endcase end always @ (posedge clk or negedge rst_n) begin if (!rst_n) begin led_int \u0026lt;= 2\u0026#39;b0; start_sig_int \u0026lt;= 1\u0026#39;b0; opt_int \u0026lt;= 2\u0026#39;b0; phy_addr_int \u0026lt;= 5\u0026#39;b0; reg_addr_int \u0026lt;= 5\u0026#39;b0; ta_int \u0026lt;= 2\u0026#39;b0; wr_data_int \u0026lt;= 16\u0026#39;b0; state_cnt \u0026lt;= 10\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; link_error \u0026lt;= 1\u0026#39;b0; speed_status \u0026lt;= 2\u0026#39;b00; end else begin case(cur_state) IDLE : begin led_int \u0026lt;= 2\u0026#39;b00; start_sig_int \u0026lt;= 1\u0026#39;b0; opt_int \u0026lt;= 2\u0026#39;b0; phy_addr_int \u0026lt;= 5\u0026#39;b0; reg_addr_int \u0026lt;= 5\u0026#39;b0; ta_int \u0026lt;= 2\u0026#39;b0; wr_data_int \u0026lt;= 16\u0026#39;b0; state_cnt \u0026lt;= 10\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; speed_status \u0026lt;= 2\u0026#39;b00; link_error \u0026lt;= 1\u0026#39;b0; end START : begin if (state_cnt == 10\u0026#39;d20) begin state_done \u0026lt;= 1\u0026#39;b1; state_cnt \u0026lt;= 10\u0026#39;b0; opt_int \u0026lt;= 2\u0026#39;b10; //read operation phy_addr_int \u0026lt;= 5\u0026#39;d4; //phy address reg_addr_int \u0026lt;= 5\u0026#39;d1; //reg address ta_int \u0026lt;= 2\u0026#39;b10; //turnaround wr_data_int \u0026lt;= 16\u0026#39;h0000; end else begin state_cnt \u0026lt;= state_cnt + 1\u0026#39;b1; state_done \u0026lt;= 1\u0026#39;b0; end end READ : begin if (state_cnt \u0026lt;= 10\u0026#39;d20) begin state_cnt \u0026lt;= state_cnt + 1\u0026#39;b1; end else begin state_cnt \u0026lt;= state_cnt; end if (state_cnt == 10\u0026#39;d2) begin opt_int \u0026lt;= 2\u0026#39;b10; //read operation phy_addr_int \u0026lt;= 5\u0026#39;d4; //phy address reg_addr_int \u0026lt;= 5\u0026#39;h1; //reg address ta_int \u0026lt;= 2\u0026#39;b10; //turnaround wr_data_int \u0026lt;= 16\u0026#39;h0000; end if (state_cnt == 10\u0026#39;d17 || state_cnt == 10\u0026#39;d18 || state_cnt == 10\u0026#39;d19) begin start_sig_int \u0026lt;= 1\u0026#39;b1; end else begin start_sig_int \u0026lt;= 1\u0026#39;b0; end end WRITE : begin if (state_cnt \u0026lt;= 10\u0026#39;d40) begin state_cnt \u0026lt;= state_cnt + 1\u0026#39;b1; end else begin state_cnt \u0026lt;= state_cnt; end if (state_cnt == 10\u0026#39;d22) begin opt_int \u0026lt;= 2\u0026#39;b01; //write operation phy_addr_int \u0026lt;= 5\u0026#39;d4; //phy address reg_addr_int \u0026lt;= 5\u0026#39;d0; //reg address ta_int \u0026lt;= 2\u0026#39;b10; //turnaround wr_data_int \u0026lt;= 16\u0026#39;h9140; end if (state_cnt == 10\u0026#39;d37 || state_cnt == 10\u0026#39;d38 || state_cnt == 10\u0026#39;d39) begin start_sig_int \u0026lt;= 1\u0026#39;b1; end else begin start_sig_int \u0026lt;= 1\u0026#39;b0; end end READ2 : begin if (state_cnt \u0026lt;= 10\u0026#39;d600) begin state_cnt \u0026lt;= state_cnt + 1\u0026#39;b1; end else begin state_cnt \u0026lt;= 10\u0026#39;d0; end if (state_cnt == 10\u0026#39;d42) begin opt_int \u0026lt;= 2\u0026#39;b10; //read operation phy_addr_int \u0026lt;= 5\u0026#39;d4; //phy address reg_addr_int \u0026lt;= 5\u0026#39;h1; //reg address ta_int \u0026lt;= 2\u0026#39;b10; //turnaround wr_data_int \u0026lt;= 16\u0026#39;h0000; end if (state_cnt == 10\u0026#39;d57 || state_cnt == 10\u0026#39;d58 || state_cnt == 10\u0026#39;d59) begin start_sig_int \u0026lt;= 1\u0026#39;b1; end else begin start_sig_int \u0026lt;= 1\u0026#39;b0; end if(mdio_rd_data_r[5] == 1\u0026#39;b1 \u0026amp;\u0026amp; mdio_rd_data_r[2] == 1\u0026#39;b1) link_error \u0026lt;= 1\u0026#39;b0; else link_error \u0026lt;= 1\u0026#39;b1; if(mdio_rd_data_r[15:14] == 2\u0026#39;b10) speed_status \u0026lt;= 2\u0026#39;b11; //1000Mbps else if(mdio_rd_data_r[15:14] == 2\u0026#39;b01) speed_status \u0026lt;= 2\u0026#39;b10; //100Mbps else if(mdio_rd_data_r[15:14] == 2\u0026#39;b00) speed_status \u0026lt;= 2\u0026#39;b01; //10Mbps else speed_status \u0026lt;= 2\u0026#39;b00; //unknown led_int \u0026lt;= link_error ? 2\u0026#39;b00 : mdio_rd_data_r[15:14]; //indicate speed status end default : begin led_int \u0026lt;= 2\u0026#39;b00; start_sig_int \u0026lt;= 1\u0026#39;b0; opt_int \u0026lt;= 2\u0026#39;b0; phy_addr_int \u0026lt;= 5\u0026#39;b0; reg_addr_int \u0026lt;= 5\u0026#39;b0; ta_int \u0026lt;= 2\u0026#39;b0; wr_data_int \u0026lt;= 16\u0026#39;b0; state_cnt \u0026lt;= 10\u0026#39;b0; state_done \u0026lt;= 1\u0026#39;b0; end endcase end end assign led = led_int; assign start_sig = start_sig_int; assign opt = opt_int; assign phy_addr = phy_addr_int; assign reg_addr = reg_addr_int; assign ta = ta_int; assign wr_data = wr_data_int; endmodule ","date":"31 August 2025","externalUrl":null,"permalink":"/docs/mdio/","section":"Docs","summary":"\u003ch1 class=\"relative group\"\u003eMDIO 接口介绍\n    \u003cdiv id=\"mdio-接口介绍\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#mdio-%e6%8e%a5%e5%8f%a3%e4%bb%8b%e7%bb%8d\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e\u003cbr\u003e\n本文是一个用于介绍 \u003cstrong\u003eMDIO（Management Data Input/Output）接口\u003c/strong\u003e 的YT8531的verilog模块示例。\u003cbr\u003e\n你可以在此基础上增删内容、替换图片和表格数据，作为项目文档或学习笔记使用。\u003c/p\u003e","title":"MDIO 接口介绍","type":"docs"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/phy/","section":"Tags","summary":"","title":"Phy","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/phy-verilog/","section":"Tags","summary":"","title":"Phy Verilog","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/scaler-verilog/","section":"Tags","summary":"","title":"Scaler Verilog","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/video-scaling/","section":"Tags","summary":"","title":"Video Scaling","type":"tags"},{"content":" FPGA 接口时序约束：set_input_delay / set_output_delay 详解 # 在 FPGA 设计中，静态时序分析（STA）默认只知道 芯片内部 的寄存器与逻辑延时。 而对于与 外部器件 之间的接口（DDR、以太网、ADC/DAC、各种并行总线等），如果不告诉工具「数据和时钟在 PCB 上的真实关系」， 那么工具根本不知道什么时候数据会到达 FPGA 引脚，也就无法真正判断时序是否满足。set_input_delay / set_output_delay 就是用来把 外部器件 + PCB 走线 的时序关系抽象成一个简单的「延时窗口」，让 STA 能够把整个链路的 setup / hold 裕量(slack) 算出来。\n下文以系统同步（system-synchronous）接口 为例，详细说明 I/O delay 的含义、计算方式以及在约束文件中的写法。\n1. 典型系统同步结构与时序图 # 下面的示意图（你给的那张图）对应的是最典型的系统同步结构：\n同一片时钟源（或其分支）驱动 外部器件寄存器 和 FPGA 寄存器。 数据从外设寄存器在某个 launch edge 被推出，通过 PCB 走线到达 FPGA 引脚， 最终在 FPGA 内部寄存器的 capture edge 被采样。 你可以在文中插入类似：\n![系统同步接口的输入输出时序](/img/input_output_timing.png)\n图中关键符号可以这样理解：\nT_clk1：时钟从时钟源到 外部器件寄存器 的走线延时（board clock delay 之一） T_clk2：时钟从时钟源到 FPGA 寄存器 的走线延时 T_co：外部器件寄存器的 clock-to-output 延时（t_co） T_su：FPGA 寄存器的 setup time T_h ：FPGA 寄存器的 hold time T_data_pcb：数据线 从外设到 FPGA 引脚的 PCB 走线延时 T_clkfpga：时钟走线到 FPGA 的延时 T_clk2virt：时钟走线到 外设 或「虚拟时钟」的延时（取决于你怎么建模） 为了进行静态时序分析，我们需要写出：\nData Arrival Time：数据实际到达 FPGA 寄存器 D 端的时间； Clock Arrival Time：时钟到达 FPGA 寄存器 CLK 端的时间； Data Required Time：为了满足 setup / hold，数据「最晚/最早」能到达的时间； Slack：裕量 = Required − Arrival（setup）/ Arrival − Required（hold）。 你图中的公式可以整理为：\n1.1 Setup 分析 # 数据到达时间（max）\n\\[\rT_{\\text{data,arr}} = T_{\\text{clk1}} + T_{co(\\max)} + T_{\\text{data\\_pcb}(\\max)}\r\\] 时钟到达时间\n\\[\rT_{\\text{clk,arr}} = T_{\\text{clk2}}\r\\] 数据要求时间（setup）\n\\[\rT_{\\text{req,setup}} = T_{\\text{clk,arr}} - T_{su}\r\\] setup slack\n\\[\r\\text{setup\\_slack} = T_{\\text{req,setup}}^{\\min} - T_{\\text{data,arr}}^{\\max}\r\\] 若 slack \u0026gt; 0，说明满足 setup 时序。\n1.2 Hold 分析 # 数据到达时间（min）\n\\[\rT_{\\text{data,arr}} = T_{\\text{clk1}} + T_{co(\\min)} + T_{\\text{data\\_pcb}(\\min)}\r\\] 时钟到达时间\n\\[\rT_{\\text{clk,arr}} = T_{\\text{clk2}}\r\\] 数据要求时间（hold）\n\\[\rT_{\\text{req,hold}} = T_{\\text{clk,arr}} + T_{h}\r\\] hold slack\n\\[\r\\text{hold\\_slack} = T_{\\text{data,arr}}^{\\min} - T_{\\text{req,hold}}^{\\max}\r\\] 若 slack \u0026gt; 0，说明满足 hold 时序。\n以上是真实物理路径的分析。\n为了让 STA 工具自动完成这些计算，我们用 set_input_delay / set_output_delay 把外设和 PCB 抽象成简单的「输入/输出延迟」。\n2. set_input_delay 的含义 # set_input_delay 约束的是：\n“外部器件 D → FPGA 引脚” 数据相对于参考时钟（虚拟时钟）的到达时间窗口。\n形式上一般写成：\nset_input_delay -clock [get_clocks virt_clk] -max [get_ports {data_in[]}] set_input_delay -clock [get_clocks virt_clk] -min [get_ports {data_in[]}]\n-max：数据 最晚 到达的时间（用来做 setup 分析） -min：数据 最早 到达的时间（用来做 hold 分析） virt_clk：通常是一个与外部设备工作时序对应的 虚拟时钟， 也可以是板上同一组系统时钟的某个分支。 因此，input delay 实际描述的是：\n「从虚拟时钟边沿算起，数据什么时候到 FPGA 引脚？」\n3. 用外设参数计算 Input Delay # 第一种方法完全基于 外设 datasheet + PCB 延时 来推导。\n3.1 定义板级延时与时钟偏斜 # board delay：数据线 PCB 延时\nmax：t_data_pcb(max) min：t_data_pcb(min) board clock skew：时钟走线到 FPGA 与到外设之间的差值\nmin：t_clkfpga(min) − t_clk2virt(max) max：t_clkfpga(max) − t_clk2virt(min) 3.2 计算公式（你给的表格） # 1. Using external timing parameters* 2. Using FPGA timing requirements Input delay (max) board delay (max) − board clock skew (min) + tco(max)\nboard delay (max) = tdata_pcb(max)\nboard clock skew (min) = tclkfpga(min) − tclk2virt(max) t − tsu\nt = (tlatch − tlaunch)\ntsu is required FPGA setup time Input delay (min) board delay (min) − board clock skew (max) + tco(min)\nboard delay (min) = tdata_pcb(min)\nboard clock skew (max) = tclkfpga(max) − tclk2virt(min) th\nth is required FPGA hold time 解释：\nInput delay (max) 表示数据相对于虚拟时钟边沿的 最晚到达时间。 它由：外设 t_co(max) + 数据走线最大延时 − 有利方向的时钟偏斜 组成。 Input delay (min) 表示数据相对于虚拟时钟边沿的 最早到达时间。 它由：外设 t_co(min) + 数据走线最小延时 − 不利方向的时钟偏斜 组成。 这样写入 STA 后，工具就能自动将 input delay 与 FPGA 内部的 T_su/T_h 综合，给出 slack。\n4. 用 FPGA 时序需求计算 Input Delay # 第二种方法主要从 FPGA 自己的 setup/hold 需求 出发来反推。\n假设外设和 FPGA 共用一个周期为 T 的时钟，时钟在外设和 FPGA 上的 观察边沿之间的偏移 为：\n\\[\rt = t_{\\text{latch}} - t_{\\text{launch}}\r\\]这里：\nt_launch：数据在外设被推出的有效边沿相对时钟源的时间 t_latch：数据在 FPGA 被采样的有效边沿相对时钟源的时间 则：\n对 setup： 数据必须在采样边沿前 t_su 进入稳定区，因此\n\\[\r\\text{Input Delay (max)} = t - t_{su}\r\\] 对 hold： 数据至少要在采样边沿后保持 t_h 的时间，因此\n\\[\r\\text{Input Delay (min)} = t_h\r\\] 如果外设和 FPGA 用的是同一条理想时钟，launch 与 capture 都是同一个上升沿， 则 t ≈ 0，此时 input delay(max) = -T_su（多数工具会结合周期和不等式自动等价转换）， 实践中通常还是结合 PCB 延时与相位去计算更精准的 t。\n5. set_output_delay 的含义 # set_output_delay 用来约束：\n“FPGA → 外设” 数据相对于外设参考时钟的到达时间窗口。\n形式上一般写成：\nset_output_delay -clock [get_clocks virt_clk] -max \u0026lt;value\u0026gt; [get_ports {data_out[*]}] set_output_delay -clock [get_clocks virt_clk] -min \u0026lt;value\u0026gt; [get_ports {data_out[*]}] -max：外设 setup 分析 对应的数据最晚到达时间 -min：外设 hold 分析 对应的数据最早到达时间 注意：输出延迟经常会出现负值，这是因为 「外设要求数据在时钟到达之前已经稳定」， 而我们是从时钟边沿向前量时间，所以会出现负号。\n6. 用外设参数计算 Output Delay # 与输入类似，只是时序方向反过来：\n数据从 FPGA 寄存器经 t_co、T_data_pcb 到外设寄存器 D 端； 外设时钟从时钟源经不同走线到外设寄存器 CLK 端。 输出延迟公式如下（你给的表）：\n1. Using external timing parameters* 2. Using FPGA timing requirements Output delay (max) board delay (max) − board clock skew (min) + tsu\nboard delay (max) = tdata_pcb(max)\nboard clock skew (min) = tclk2virt(min) − tclkfpga(max) t − tco(max)\nt = (tlatch − tlaunch)\ntco(max) is required FPGA maximum clock-to-output time Output delay (min) board delay (min) − board clock skew (max) − th\nboard delay (min) = tdata_pcb(min)\nboard clock skew (max) = tclk2virt(max) − tclkfpga(min) −tco(min)\ntco(min) is required FPGA minimum clock-to-output time 解释要点：\nOutput delay (max)： 对应外设的 setup 检查。 由「数据线最长延时 + 外设 setup − 有利方向的时钟偏斜」得到。\nOutput delay (min)： 对应外设的 hold 检查。 由于hold 约束通常要求数据不要过早离开稳定区， 在从时钟边沿往回量时，常常表现为负值：board delay − skew − t_h。\n第二列等价写法是从 FPGA 的 t_co 出发反推， 把外设的要求折算成 t − t_co(max) / −t_co(min) 的形式。\n7. 在约束文件中的典型写法示例 # 假设：\n外设和 FPGA 共用 100 MHz 系统时钟，周期 T = 10ns； 我们在 FPGA 内部创建一个虚拟时钟 virt_clk 表示外设的采样时钟； 数据线为 rx_data[7:0]（输入）和 tx_data[7:0]（输出）。 7.1 创建虚拟时钟 # create_clock -name virt_clk -period 10.0 [get_ports sys_clk] 或者如果外设时钟是由 FPGA 输出的一路时钟（例如 clk_out）：\ncreate_generated_clock -name virt_clk \\ -source [get_pins pll_inst/clk_out] \\ -divide_by 1 [get_ports clk_to_device] 7.2 约束输入端口 # 假设经过计算得到：\nInput delay(max) = 4.2ns Input delay(min) = 0.8ns 则：\nset_input_delay -clock [get_clocks virt_clk] -max 4.2 [get_ports {rx_data[*]}] set_input_delay -clock [get_clocks virt_clk] -min 0.8 [get_ports {rx_data[*]}] 7.3 约束输出端口 # 假设计算得到：\nOutput delay(max) = 3.5ns Output delay(min) = -0.5ns ; // 注意是负值 set_output_delay -clock [get_clocks virt_clk] -max 3.5 [get_ports {tx_data[*]}] set_output_delay -clock [get_clocks virt_clk] -min -0.5 [get_ports {tx_data[*]}] 工具会自动把这些延迟与 FPGA 内部路径、PLL 相位、clock uncertainty 等综合起来， 给出完整的 setup / hold slack 报告。\n8. 常见问题与坑 # 只写 max 不写 min\n很多设计只写 -max，导致 hold 完全没有被约束， 工具会默认 min = max 或 min = 0，极易出现板上 sporadic 错误。 忽略板级时钟偏斜（clock skew）\n数据走线和时钟走线的拓扑若差异明显，skew 可能达到几百 ps 甚至 1ns 以上， 直接影响 setup/hold 裕量，必须计入。 输出 delay 符号搞反\n记住：输出的 -min 通常是负值（数据在时钟到达 之前 就应稳定）。 如果仍然写成正数，会把 hold 约束搞反，留下隐患。 没有区分不同接口组\n不同连接器、不同 bank 的线路长度差异较大时， 建议为每组接口使用不同的 delay 值，避免用一个「平均值」掩盖边缘 case。 重复统计 jitter / margin\n时钟不确定度（uncertainty / jitter）既可以通过 set_clock_uncertainty 加， 也可以在 delay 里预留 margin。 但不要两边同时加太多，否则时序会变得过于悲观。 9. 小结 # set_input_delay / set_output_delay 本质上是在 STA 中为外设 + PCB 建一个时序黑盒模型；\n通过「数据到达时间窗口」和「参考时钟」的关系，工具就能算出完整的 setup/hold slack；\nInput/Output delay 可以从两种角度推导：\n基于外设 datasheet + PCB 延时； 基于 FPGA 自身的 t_su / t_h / t_co 与时钟相位关系； 正确区分 max/min，考虑板级 clock skew，是 I/O 时序可靠性的关键。\n把上面的公式和你画的两张图放到一起，这就是一篇比较完整、专业的 系统同步 I/O 时序约束教程 了。你可以在项目里直接复用表格和公式， 只要把 t_data_pcb, t_clkfpga, t_clk2virt, t_co, t_su, t_h 换成自己板子的实测或估算值即可。\n1. Using external timing parameters* 2. Using FPGA timing requirements Input delay (max) board delay (max) − board clock skew (min) + t_co(max)\nboard delay (max) = t_data_pcb(max)\nboard clock skew (min) = t_clkfpga(min) − t_clk2virt(max) t − t_su\nt = (t_latch − t_launch)\nt_su is required FPGA setup time Input delay (min) board delay (min) − board clock skew (max) + t_co(min)\nboard delay (min) = t_data_pcb(min)\nboard clock skew (max) = t_clkfpga(max) − t_clk2virt(min) t_h\nt_h is required FPGA hold time 1. Using external timing parameters* 2. Using FPGA timing requirements Output delay (max) board delay (max) − board clock skew (min) + t_su\nboard delay (max) = t_data_pcb(max)\nboard clock skew (min) = t_clk2virt(min) − t_clkfpga(max) t − t_co(max)\nt = (t_latch − t_launch)\nt_co(max) is required FPGA maximum clock-to-output time Output delay (min) board delay (min) − board clock skew (max) − t_h\nboard delay (min) = t_data_pcb(min)\nboard clock skew (max) = t_clk2virt(max) − t_clkfpga(min) −t_co(min)\nt_co(min) is required FPGA minimum clock-to-output time ","externalUrl":null,"permalink":"/docs/timing/","section":"Docs","summary":"\u003ch1 class=\"relative group\"\u003eFPGA 接口时序约束：set_input_delay / set_output_delay 详解\n    \u003cdiv id=\"fpga-接口时序约束set_input_delay--set_output_delay-详解\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"text-primary-300 dark:text-neutral-700 !no-underline\" href=\"#fpga-%e6%8e%a5%e5%8f%a3%e6%97%b6%e5%ba%8f%e7%ba%a6%e6%9d%9fset_input_delay--set_output_delay-%e8%af%a6%e8%a7%a3\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e\n    \n\u003c/h1\u003e\n\u003cp\u003e在 FPGA 设计中，静态时序分析（STA）默认只知道 \u003cstrong\u003e芯片内部\u003c/strong\u003e 的寄存器与逻辑延时。  而对于与 \u003cstrong\u003e外部器件\u003c/strong\u003e 之间的接口（DDR、以太网、ADC/DAC、各种并行总线等），如果不告诉工具「数据和时钟在 PCB 上的真实关系」，  那么工具根本不知道什么时候数据会到达 FPGA 引脚，也就无法真正判断时序是否满足。\u003ccode\u003eset_input_delay\u003c/code\u003e / \u003ccode\u003eset_output_delay\u003c/code\u003e 就是用来把 \u003cstrong\u003e外部器件 + PCB 走线\u003c/strong\u003e 的时序关系抽象成一个简单的「延时窗口」，让 STA 能够把整个链路的 \u003cstrong\u003esetup / hold 裕量(slack)\u003c/strong\u003e 算出来。\u003c/p\u003e","title":"","type":"docs"},{"content":"","externalUrl":null,"permalink":"/zh-cn/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/zh-cn/","section":"LANIAKEA","summary":"","title":"LANIAKEA","type":"page"},{"content":"","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]







[{"content":"Bilinear interpolation 是一种在嵌入式和 FPGA 上都很实用的图像缩放方法。\n每个输出像素由源图像中最近的四个像素加权平均得到，比最近邻平滑得多，又比高阶滤波器便宜很多。\n本篇主要讲数学和坐标映射；下一篇会对应 Verilog 架构和实现。\n1. 坐标映射：输出像素来自源图像的哪里？ # 设原图尺寸为 w × h，目标图尺寸为 new_w × new_h。则缩放因子为：\n水平方向：scale_x = w / new_w 垂直方向：scale_y = h / new_h 对目标图中整数坐标 (i, j)（0-based），映射到源图中的连续坐标 (src_x, src_y)：\nsrc_x = (i + 0.5) * scale_x - 0.5 src_y = (j + 0.5) * scale_y - 0.5 +0.5 与 -0.5 的作用是让像素中心对齐：当缩放比例为 1× 时，输出图像不会整体平移。([1 Bit FPGA][1])\n接着将连续坐标拆分为整数部分与小数部分：\nx_int = floor(src_x) y_int = floor(src_y) a_x = src_x - x_int // 0..1 a_y = src_y - y_int // 0..1 四个相邻的整数栅格点分别是：\nQ11 = (x_int, y_int) Q21 = (x_int + 1, y_int) Q12 = (x_int, y_int + 1) Q22 = (x_int + 1, y_int + 1) 2. 两种等价的插值公式 # 设灰度值或某个颜色通道的值记为 f(·)。\n2.1 先横向后纵向的两步线性插值（LERP） # 水平方向插值： f(x, y_int) = (1 - a_x) * f(Q11) + a_x * f(Q21) f(x, y_int + 1) = (1 - a_x) * f(Q12) + a_x * f(Q22) 垂直方向插值： I(x, y) = (1 - a_y) * f(x, y_int) + a_y * f(x, y_int + 1) 2.2 一步完成的加权和公式 # 把上下两步合并，可写成四个点的加权和：([1 Bit FPGA][1])\nI(x, y) = (1 - a_x) * (1 - a_y) * f(Q11) + a_x * (1 - a_y) * f(Q21) + (1 - a_x) * a_y * f(Q12) + a_x * a_y * f(Q22) 在 RGB 图像中，对 R/G/B 三个通道分别独立应用同样的插值权重即可。\n3. 示例：4×4 放大到 8×8（单通道） # 原始 4×4 像素值示例：\n10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 目标是放大为 8 × 8，因此缩放因子为：\nscale_x = scale_y = 4 / 8 = 0.5 考虑目标图上像素 (i, j) = (1, 1)：\n映射回源图坐标： src_x = (1 + 0.5) * 0.5 - 0.5 = 0.25 src_y = (1 + 0.5) * 0.5 - 0.5 = 0.25 x_int = 0, y_int = 0 a_x = 0.25 a_y = 0.25 查找四个邻点及其值： Q11 = (0, 0) -\u0026gt; 10 Q21 = (1, 0) -\u0026gt; 20 Q12 = (0, 1) -\u0026gt; 50 Q22 = (1, 1) -\u0026gt; 60 两步插值计算： f(x, y_int) = 0.75 * 10 + 0.25 * 20 = 12.5 f(x, y_int + 1) = 0.75 * 50 + 0.25 * 60 = 52.5 I(x, y) = 0.75 * 12.5 + 0.25 * 52.5 = 22.5 实际图像中，会再根据约定进行取整，例如向最近整数四舍五入，得到 22 或 23。([1 Bit FPGA][1])\n4. 对矩阵进行双线性插值的 Python 示例 # 下面是一个使用 NumPy 实现双线性插值的示例函数，用于将任意大小的 2D 数组缩放到新尺寸。代码思路与文中示例一致，但变量命名和注释略有调整，便于直接复用在工程中。\nimport numpy as np def bilinear_interpolation(input_matrix: np.ndarray, new_shape): \u0026#34;\u0026#34;\u0026#34; Resize a 2D matrix using bilinear interpolation. input_matrix: 2D numpy array, shape (src_h, src_w) new_shape: tuple (dst_h, dst_w) \u0026#34;\u0026#34;\u0026#34; src_h, src_w = input_matrix.shape dst_h, dst_w = new_shape output = np.zeros((dst_h, dst_w), dtype=float) # 注意：这里使用 (N-1)/(M-1) 的写法，可以保证首尾像素对齐 scale_x = (src_w - 1) / (dst_w - 1) if dst_w \u0026gt; 1 else 0.0 scale_y = (src_h - 1) / (dst_h - 1) if dst_h \u0026gt; 1 else 0.0 for i in range(dst_h): for j in range(dst_w): # 映射到源图连续坐标（以像素中心为基准） src_x = (j + 0.5) * scale_x - 0.5 src_y = (i + 0.5) * scale_y - 0.5 x0 = int(np.floor(src_x)) y0 = int(np.floor(src_y)) x1 = min(x0 + 1, src_w - 1) y1 = min(y0 + 1, src_h - 1) wx = src_x - x0 wy = src_y - y0 # 四个点加权求和 v00 = input_matrix[y0, x0] v10 = input_matrix[y0, x1] v01 = input_matrix[y1, x0] v11 = input_matrix[y1, x1] output[i, j] = ( v00 * (1 - wx) * (1 - wy) + v10 * wx * (1 - wy) + v01 * (1 - wx) * wy + v11 * wx * wy ) return output 你可以用文中的 4×4 示例矩阵验证：\ninput_matrix = np.array([ [10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160], ]) output_matrix = bilinear_interpolation(input_matrix, (8, 8)) print(output_matrix) ","date":"31 August 2025","externalUrl":null,"permalink":"/docs/hello-world/","section":"Docs","summary":"\u003cp\u003eBilinear interpolation 是一种在嵌入式和 FPGA 上都很实用的图像缩放方法。\u003cbr\u003e\n每个输出像素由源图像中最近的四个像素加权平均得到，比最近邻平滑得多，又比高阶滤波器便宜很多。\u003c/p\u003e","title":"Bilinear Image Scaling in Verilog: Bilinear Interpolation Explanation","type":"docs"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/bilinear-verilog/","section":"Tags","summary":"","title":"Bilinear Verilog","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/bilinear-image-scaling/","section":"Tags","summary":"","title":"Bilinear-Image-Scaling","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/docs/","section":"Docs","summary":"","title":"Docs","type":"docs"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/scaler-verilog/","section":"Tags","summary":"","title":"Scaler Verilog","type":"tags"},{"content":"","date":"31 August 2025","externalUrl":null,"permalink":"/tags/video-scaling/","section":"Tags","summary":"","title":"Video Scaling","type":"tags"},{"content":"","externalUrl":null,"permalink":"/zh-cn/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/zh-cn/","section":"Blowfish","summary":"","title":"Blowfish","type":"page"},{"content":"","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]